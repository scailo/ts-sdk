// @generated by protoc-gen-es v1.5.1 with parameter "target=ts"
// @generated from file base.scailo.proto (package Scailo, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 *
 * Describes the order in which the records need to be returned
 *
 * @generated from enum Scailo.SORT_ORDER
 */
export enum SORT_ORDER {
  /**
   * Fetch results in the ascending order of the provided sort key
   *
   * @generated from enum value: ASCENDING_UNSPECIFIED = 0;
   */
  ASCENDING_UNSPECIFIED = 0,

  /**
   * Fetch results in the descending order of the provided sort key
   *
   * @generated from enum value: DESCENDING = 1;
   */
  DESCENDING = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(SORT_ORDER)
proto3.util.setEnumType(SORT_ORDER, "Scailo.SORT_ORDER", [
  { no: 0, name: "ASCENDING_UNSPECIFIED" },
  { no: 1, name: "DESCENDING" },
]);

/**
 *
 * Describes the standard lifecycle status of each record
 *
 * @generated from enum Scailo.STANDARD_LIFECYCLE_STATUS
 */
export enum STANDARD_LIFECYCLE_STATUS {
  /**
   * Use this only in filter and search queries so as to retrieve all the records regardless of the status that they are in
   *
   * @generated from enum value: ANY_UNSPECIFIED = 0;
   */
  ANY_UNSPECIFIED = 0,

  /**
   * The resource has just been created, and has been sent for verification
   *
   * @generated from enum value: PREVERIFY = 1;
   */
  PREVERIFY = 1,

  /**
   * The resource has been saved as a draft
   *
   * @generated from enum value: DRAFT = 2;
   */
  DRAFT = 2,

  /**
   * The resource has been verified
   *
   * @generated from enum value: VERIFIED = 3;
   */
  VERIFIED = 3,

  /**
   * The resource has been approved
   *
   * @generated from enum value: STANDING = 4;
   */
  STANDING = 4,

  /**
   * The resource has been sent for revision
   *
   * @generated from enum value: REVISION = 5;
   */
  REVISION = 5,

  /**
   * The resource has been halted
   *
   * @generated from enum value: HALTED = 6;
   */
  HALTED = 6,

  /**
   * The resource has been marked as completed
   *
   * @generated from enum value: COMPLETED = 7;
   */
  COMPLETED = 7,

  /**
   * The resource has been discarded
   *
   * @generated from enum value: DISCARDED = 8;
   */
  DISCARDED = 8,
}
// Retrieve enum metadata with: proto3.getEnumType(STANDARD_LIFECYCLE_STATUS)
proto3.util.setEnumType(STANDARD_LIFECYCLE_STATUS, "Scailo.STANDARD_LIFECYCLE_STATUS", [
  { no: 0, name: "ANY_UNSPECIFIED" },
  { no: 1, name: "PREVERIFY" },
  { no: 2, name: "DRAFT" },
  { no: 3, name: "VERIFIED" },
  { no: 4, name: "STANDING" },
  { no: 5, name: "REVISION" },
  { no: 6, name: "HALTED" },
  { no: 7, name: "COMPLETED" },
  { no: 8, name: "DISCARDED" },
]);

/**
 *
 * Describes the available form types
 *
 * @generated from enum Scailo.FORM_TYPE
 */
export enum FORM_TYPE {
  /**
   * Use this only in filter and search queries so as to retrieve all the records regardless of the form type that they are in
   *
   * @generated from enum value: FORM_TYPE_ANY_UNSPECIFIED = 0;
   */
  FORM_TYPE_ANY_UNSPECIFIED = 0,

  /**
   * The form type is "sales-enquiry-form"
   *
   * @generated from enum value: FORM_TYPE_SALES_ENQUIRY_FORM = 10;
   */
  FORM_TYPE_SALES_ENQUIRY_FORM = 10,

  /**
   * The form type is "purchase-enquiry-form"
   *
   * @generated from enum value: FORM_TYPE_PURCHASE_ENQUIRY_FORM = 20;
   */
  FORM_TYPE_PURCHASE_ENQUIRY_FORM = 20,

  /**
   * The form type is "project-form"
   *
   * @generated from enum value: FORM_TYPE_PROJECT_FORM = 30;
   */
  FORM_TYPE_PROJECT_FORM = 30,

  /**
   * The form type is "sales-order-form"
   *
   * @generated from enum value: FORM_TYPE_SALES_ORDER_FORM = 40;
   */
  FORM_TYPE_SALES_ORDER_FORM = 40,

  /**
   * The form type is "sales-quotation-form"
   *
   * @generated from enum value: FORM_TYPE_SALES_QUOTATION_FORM = 50;
   */
  FORM_TYPE_SALES_QUOTATION_FORM = 50,

  /**
   * The form type is "client-form"
   *
   * @generated from enum value: FORM_TYPE_CLIENT_FORM = 60;
   */
  FORM_TYPE_CLIENT_FORM = 60,

  /**
   * The form type is "user-form"
   *
   * @generated from enum value: FORM_TYPE_USER_FORM = 70;
   */
  FORM_TYPE_USER_FORM = 70,

  /**
   * The form type is "purchase-order-form"
   *
   * @generated from enum value: FORM_TYPE_PURCHASE_ORDER_FORM = 80;
   */
  FORM_TYPE_PURCHASE_ORDER_FORM = 80,

  /**
   * The form type is "supply-offer-form"
   *
   * @generated from enum value: FORM_TYPE_SUPPLY_OFFER_FORM = 85;
   */
  FORM_TYPE_SUPPLY_OFFER_FORM = 85,

  /**
   * The form type is "purchase-indent-form"
   *
   * @generated from enum value: FORM_TYPE_PURCHASE_INDENT_FORM = 90;
   */
  FORM_TYPE_PURCHASE_INDENT_FORM = 90,

  /**
   * The form type is "sales-invoice-form"
   *
   * @generated from enum value: FORM_TYPE_SALES_INVOICE_FORM = 100;
   */
  FORM_TYPE_SALES_INVOICE_FORM = 100,

  /**
   * The form type is "proforma-invoice-form"
   *
   * @generated from enum value: FORM_TYPE_PROFORMA_INVOICE_FORM = 105;
   */
  FORM_TYPE_PROFORMA_INVOICE_FORM = 105,

  /**
   * The form type is "goods-dispatch-form"
   *
   * @generated from enum value: FORM_TYPE_GOODS_DISPATCH_FORM = 110;
   */
  FORM_TYPE_GOODS_DISPATCH_FORM = 110,

  /**
   * The form type is "vendor-invoice-form"
   *
   * @generated from enum value: FORM_TYPE_VENDOR_INVOICE_FORM = 120;
   */
  FORM_TYPE_VENDOR_INVOICE_FORM = 120,

  /**
   * The form type is "goods-receipt-form"
   *
   * @generated from enum value: FORM_TYPE_GOODS_RECEIPT_FORM = 130;
   */
  FORM_TYPE_GOODS_RECEIPT_FORM = 130,

  /**
   * The form type is "work-order-form"
   *
   * @generated from enum value: FORM_TYPE_WORK_ORDER_FORM = 140;
   */
  FORM_TYPE_WORK_ORDER_FORM = 140,

  /**
   * The form type is "vendor-form"
   *
   * @generated from enum value: FORM_TYPE_VENDOR_FORM = 150;
   */
  FORM_TYPE_VENDOR_FORM = 150,

  /**
   * The form type is "stock-issuance-form"
   *
   * @generated from enum value: FORM_TYPE_STOCK_ISSUANCE_FORM = 160;
   */
  FORM_TYPE_STOCK_ISSUANCE_FORM = 160,

  /**
   * The form type is "stock-audit-form"
   *
   * @generated from enum value: FORM_TYPE_STOCK_AUDIT_FORM = 170;
   */
  FORM_TYPE_STOCK_AUDIT_FORM = 170,

  /**
   * The form type is "stock-return-form"
   *
   * @generated from enum value: FORM_TYPE_STOCK_RETURN_FORM = 180;
   */
  FORM_TYPE_STOCK_RETURN_FORM = 180,

  /**
   * The form type is "expense-form"
   *
   * @generated from enum value: FORM_TYPE_EXPENSE_FORM = 190;
   */
  FORM_TYPE_EXPENSE_FORM = 190,

  /**
   * The form type is "location-form"
   *
   * @generated from enum value: FORM_TYPE_LOCATION_FORM = 200;
   */
  FORM_TYPE_LOCATION_FORM = 200,

  /**
   * The form type is "bank-account-form"
   *
   * @generated from enum value: FORM_TYPE_BANK_ACCOUNT_FORM = 210;
   */
  FORM_TYPE_BANK_ACCOUNT_FORM = 210,

  /**
   * The form type is "qc-group-form"
   *
   * @generated from enum value: FORM_TYPE_QC_GROUP_FORM = 220;
   */
  FORM_TYPE_QC_GROUP_FORM = 220,

  /**
   * The form type is "quotation-request-form"
   *
   * @generated from enum value: FORM_TYPE_QUOTATION_REQUEST_FORM = 230;
   */
  FORM_TYPE_QUOTATION_REQUEST_FORM = 230,

  /**
   * The form type is "quotation-response-form"
   *
   * @generated from enum value: FORM_TYPE_QUOTATION_RESPONSE_FORM = 240;
   */
  FORM_TYPE_QUOTATION_RESPONSE_FORM = 240,

  /**
   * The form type is "production-plan-form"
   *
   * @generated from enum value: FORM_TYPE_PRODUCTION_PLAN_FORM = 250;
   */
  FORM_TYPE_PRODUCTION_PLAN_FORM = 250,

  /**
   * The form type is "production-indent-form"
   *
   * @generated from enum value: FORM_TYPE_PRODUCTION_INDENT_FORM = 260;
   */
  FORM_TYPE_PRODUCTION_INDENT_FORM = 260,

  /**
   * The form type is "replaceable-indent-form"
   *
   * @generated from enum value: FORM_TYPE_REPLACEABLE_INDENT_FORM = 270;
   */
  FORM_TYPE_REPLACEABLE_INDENT_FORM = 270,

  /**
   * The form type is "asset-indent-form"
   *
   * @generated from enum value: FORM_TYPE_ASSET_INDENT_FORM = 280;
   */
  FORM_TYPE_ASSET_INDENT_FORM = 280,

  /**
   * The form type is "purchase-return-form"
   *
   * @generated from enum value: FORM_TYPE_PURCHASE_RETURN_FORM = 290;
   */
  FORM_TYPE_PURCHASE_RETURN_FORM = 290,

  /**
   * The form type is "sales-return-form"
   *
   * @generated from enum value: FORM_TYPE_SALES_RETURN_FORM = 300;
   */
  FORM_TYPE_SALES_RETURN_FORM = 300,

  /**
   * The form type is "debit-note-form"
   *
   * @generated from enum value: FORM_TYPE_DEBIT_NOTE_FORM = 310;
   */
  FORM_TYPE_DEBIT_NOTE_FORM = 310,

  /**
   * The form type is "credit-note-form"
   *
   * @generated from enum value: FORM_TYPE_CREDIT_NOTE_FORM = 320;
   */
  FORM_TYPE_CREDIT_NOTE_FORM = 320,

  /**
   * The form type is "inward-job-form"
   *
   * @generated from enum value: FORM_TYPE_INWARD_JOB_FORM = 330;
   */
  FORM_TYPE_INWARD_JOB_FORM = 330,

  /**
   * The form type is "inward-job-free-issue-material-form"
   *
   * @generated from enum value: FORM_TYPE_INWARD_JOB_FREE_ISSUE_MATERIAL_FORM = 340;
   */
  FORM_TYPE_INWARD_JOB_FREE_ISSUE_MATERIAL_FORM = 340,

  /**
   * The form type is "inward-job-free-issue-material-return-form"
   *
   * @generated from enum value: FORM_TYPE_INWARD_JOB_FREE_ISSUE_MATERIAL_RETURN_FORM = 350;
   */
  FORM_TYPE_INWARD_JOB_FREE_ISSUE_MATERIAL_RETURN_FORM = 350,

  /**
   * The form type is "outward-job-form"
   *
   * @generated from enum value: FORM_TYPE_OUTWARD_JOB_FORM = 360;
   */
  FORM_TYPE_OUTWARD_JOB_FORM = 360,

  /**
   * The form type is "outward-job-free-issue-material-form"
   *
   * @generated from enum value: FORM_TYPE_OUTWARD_JOB_FREE_ISSUE_MATERIAL_FORM = 370;
   */
  FORM_TYPE_OUTWARD_JOB_FREE_ISSUE_MATERIAL_FORM = 370,

  /**
   * The form type is "outward-job-free-issue-material-return-form"
   *
   * @generated from enum value: FORM_TYPE_OUTWARD_JOB_FREE_ISSUE_MATERIAL_RETURN_FORM = 380;
   */
  FORM_TYPE_OUTWARD_JOB_FREE_ISSUE_MATERIAL_RETURN_FORM = 380,

  /**
   * The form type is "leave-request-form"
   *
   * @generated from enum value: FORM_TYPE_LEAVE_REQUEST_FORM = 390;
   */
  FORM_TYPE_LEAVE_REQUEST_FORM = 390,

  /**
   * The form type is "overtime-form"
   *
   * @generated from enum value: FORM_TYPE_OVERTIME_FORM = 400;
   */
  FORM_TYPE_OVERTIME_FORM = 400,

  /**
   * The form type is "attendance-form"
   *
   * @generated from enum value: FORM_TYPE_ATTENDANCE_FORM = 410;
   */
  FORM_TYPE_ATTENDANCE_FORM = 410,

  /**
   * The form type is "absence-form"
   *
   * @generated from enum value: FORM_TYPE_ABSENCE_FORM = 420;
   */
  FORM_TYPE_ABSENCE_FORM = 420,

  /**
   * The form type is "onduty-form"
   *
   * @generated from enum value: FORM_TYPE_ONDUTY_FORM = 430;
   */
  FORM_TYPE_ONDUTY_FORM = 430,

  /**
   * The form type is "attendanceamendment-form"
   *
   * @generated from enum value: FORM_TYPE_ATTENDANCE_AMENDMENT_FORM = 440;
   */
  FORM_TYPE_ATTENDANCE_AMENDMENT_FORM = 440,

  /**
   * The form type is "visitation-form"
   *
   * @generated from enum value: FORM_TYPE_VISITATION_FORM = 450;
   */
  FORM_TYPE_VISITATION_FORM = 450,

  /**
   * The form type is "salary-form"
   *
   * @generated from enum value: FORM_TYPE_SALARY_FORM = 490;
   */
  FORM_TYPE_SALARY_FORM = 490,

  /**
   * The form type is "skill-param-form"
   *
   * @generated from enum value: FORM_TYPE_SKILL_PARAM_FORM = 500;
   */
  FORM_TYPE_SKILL_PARAM_FORM = 500,

  /**
   * The form type is "skill-group-form"
   *
   * @generated from enum value: FORM_TYPE_SKILL_GROUP_FORM = 510;
   */
  FORM_TYPE_SKILL_GROUP_FORM = 510,

  /**
   * The form type is "goal-form"
   *
   * @generated from enum value: FORM_TYPE_GOAL_FORM = 520;
   */
  FORM_TYPE_GOAL_FORM = 520,

  /**
   * The form type is "meeting-form"
   *
   * @generated from enum value: FORM_TYPE_MEETING_FORM = 530;
   */
  FORM_TYPE_MEETING_FORM = 530,
}
// Retrieve enum metadata with: proto3.getEnumType(FORM_TYPE)
proto3.util.setEnumType(FORM_TYPE, "Scailo.FORM_TYPE", [
  { no: 0, name: "FORM_TYPE_ANY_UNSPECIFIED" },
  { no: 10, name: "FORM_TYPE_SALES_ENQUIRY_FORM" },
  { no: 20, name: "FORM_TYPE_PURCHASE_ENQUIRY_FORM" },
  { no: 30, name: "FORM_TYPE_PROJECT_FORM" },
  { no: 40, name: "FORM_TYPE_SALES_ORDER_FORM" },
  { no: 50, name: "FORM_TYPE_SALES_QUOTATION_FORM" },
  { no: 60, name: "FORM_TYPE_CLIENT_FORM" },
  { no: 70, name: "FORM_TYPE_USER_FORM" },
  { no: 80, name: "FORM_TYPE_PURCHASE_ORDER_FORM" },
  { no: 85, name: "FORM_TYPE_SUPPLY_OFFER_FORM" },
  { no: 90, name: "FORM_TYPE_PURCHASE_INDENT_FORM" },
  { no: 100, name: "FORM_TYPE_SALES_INVOICE_FORM" },
  { no: 105, name: "FORM_TYPE_PROFORMA_INVOICE_FORM" },
  { no: 110, name: "FORM_TYPE_GOODS_DISPATCH_FORM" },
  { no: 120, name: "FORM_TYPE_VENDOR_INVOICE_FORM" },
  { no: 130, name: "FORM_TYPE_GOODS_RECEIPT_FORM" },
  { no: 140, name: "FORM_TYPE_WORK_ORDER_FORM" },
  { no: 150, name: "FORM_TYPE_VENDOR_FORM" },
  { no: 160, name: "FORM_TYPE_STOCK_ISSUANCE_FORM" },
  { no: 170, name: "FORM_TYPE_STOCK_AUDIT_FORM" },
  { no: 180, name: "FORM_TYPE_STOCK_RETURN_FORM" },
  { no: 190, name: "FORM_TYPE_EXPENSE_FORM" },
  { no: 200, name: "FORM_TYPE_LOCATION_FORM" },
  { no: 210, name: "FORM_TYPE_BANK_ACCOUNT_FORM" },
  { no: 220, name: "FORM_TYPE_QC_GROUP_FORM" },
  { no: 230, name: "FORM_TYPE_QUOTATION_REQUEST_FORM" },
  { no: 240, name: "FORM_TYPE_QUOTATION_RESPONSE_FORM" },
  { no: 250, name: "FORM_TYPE_PRODUCTION_PLAN_FORM" },
  { no: 260, name: "FORM_TYPE_PRODUCTION_INDENT_FORM" },
  { no: 270, name: "FORM_TYPE_REPLACEABLE_INDENT_FORM" },
  { no: 280, name: "FORM_TYPE_ASSET_INDENT_FORM" },
  { no: 290, name: "FORM_TYPE_PURCHASE_RETURN_FORM" },
  { no: 300, name: "FORM_TYPE_SALES_RETURN_FORM" },
  { no: 310, name: "FORM_TYPE_DEBIT_NOTE_FORM" },
  { no: 320, name: "FORM_TYPE_CREDIT_NOTE_FORM" },
  { no: 330, name: "FORM_TYPE_INWARD_JOB_FORM" },
  { no: 340, name: "FORM_TYPE_INWARD_JOB_FREE_ISSUE_MATERIAL_FORM" },
  { no: 350, name: "FORM_TYPE_INWARD_JOB_FREE_ISSUE_MATERIAL_RETURN_FORM" },
  { no: 360, name: "FORM_TYPE_OUTWARD_JOB_FORM" },
  { no: 370, name: "FORM_TYPE_OUTWARD_JOB_FREE_ISSUE_MATERIAL_FORM" },
  { no: 380, name: "FORM_TYPE_OUTWARD_JOB_FREE_ISSUE_MATERIAL_RETURN_FORM" },
  { no: 390, name: "FORM_TYPE_LEAVE_REQUEST_FORM" },
  { no: 400, name: "FORM_TYPE_OVERTIME_FORM" },
  { no: 410, name: "FORM_TYPE_ATTENDANCE_FORM" },
  { no: 420, name: "FORM_TYPE_ABSENCE_FORM" },
  { no: 430, name: "FORM_TYPE_ONDUTY_FORM" },
  { no: 440, name: "FORM_TYPE_ATTENDANCE_AMENDMENT_FORM" },
  { no: 450, name: "FORM_TYPE_VISITATION_FORM" },
  { no: 490, name: "FORM_TYPE_SALARY_FORM" },
  { no: 500, name: "FORM_TYPE_SKILL_PARAM_FORM" },
  { no: 510, name: "FORM_TYPE_SKILL_GROUP_FORM" },
  { no: 520, name: "FORM_TYPE_GOAL_FORM" },
  { no: 530, name: "FORM_TYPE_MEETING_FORM" },
]);

/**
 *
 * Describes the available form field elements
 *
 * @generated from enum Scailo.FORM_FIELD_ELEMENT
 */
export enum FORM_FIELD_ELEMENT {
  /**
   * Use this only in filter and search queries so as to retrieve all the records regardless of the form type that they are in
   *
   * @generated from enum value: FORM_FIELD_ELEMENT_ANY_UNSPECIFIED = 0;
   */
  FORM_FIELD_ELEMENT_ANY_UNSPECIFIED = 0,

  /**
   * The element is an input
   *
   * @generated from enum value: FORM_FIELD_ELEMENT_INPUT = 10;
   */
  FORM_FIELD_ELEMENT_INPUT = 10,

  /**
   * The element is a radio button
   *
   * @generated from enum value: FORM_FIELD_ELEMENT_RADIO = 20;
   */
  FORM_FIELD_ELEMENT_RADIO = 20,

  /**
   * The element is a checkbox
   *
   * @generated from enum value: FORM_FIELD_ELEMENT_CHECKBOX = 30;
   */
  FORM_FIELD_ELEMENT_CHECKBOX = 30,

  /**
   * The element is a dropdown
   *
   * @generated from enum value: FORM_FIELD_ELEMENT_SELECT = 40;
   */
  FORM_FIELD_ELEMENT_SELECT = 40,

  /**
   * The element is a multiline textarea
   *
   * @generated from enum value: FORM_FIELD_ELEMENT_TEXTAREA = 50;
   */
  FORM_FIELD_ELEMENT_TEXTAREA = 50,

  /**
   * The element is a date input
   *
   * @generated from enum value: FORM_FIELD_ELEMENT_DATE = 60;
   */
  FORM_FIELD_ELEMENT_DATE = 60,

  /**
   * The element is an email address input
   *
   * @generated from enum value: FORM_FIELD_ELEMENT_EMAIL = 70;
   */
  FORM_FIELD_ELEMENT_EMAIL = 70,

  /**
   * The element is a phone number input
   *
   * @generated from enum value: FORM_FIELD_ELEMENT_PHONE = 80;
   */
  FORM_FIELD_ELEMENT_PHONE = 80,
}
// Retrieve enum metadata with: proto3.getEnumType(FORM_FIELD_ELEMENT)
proto3.util.setEnumType(FORM_FIELD_ELEMENT, "Scailo.FORM_FIELD_ELEMENT", [
  { no: 0, name: "FORM_FIELD_ELEMENT_ANY_UNSPECIFIED" },
  { no: 10, name: "FORM_FIELD_ELEMENT_INPUT" },
  { no: 20, name: "FORM_FIELD_ELEMENT_RADIO" },
  { no: 30, name: "FORM_FIELD_ELEMENT_CHECKBOX" },
  { no: 40, name: "FORM_FIELD_ELEMENT_SELECT" },
  { no: 50, name: "FORM_FIELD_ELEMENT_TEXTAREA" },
  { no: 60, name: "FORM_FIELD_ELEMENT_DATE" },
  { no: 70, name: "FORM_FIELD_ELEMENT_EMAIL" },
  { no: 80, name: "FORM_FIELD_ELEMENT_PHONE" },
]);

/**
 *
 * Describes all the possible values within a logbook operation
 *
 * @generated from enum Scailo.LOGBOOK_OPERATION
 */
export enum LOGBOOK_OPERATION {
  /**
   * Create a resource
   *
   * @generated from enum value: CREATE_UNSPECIFIED = 0;
   */
  CREATE_UNSPECIFIED = 0,

  /**
   * Update a resource
   *
   * @generated from enum value: UPDATE = 1;
   */
  UPDATE = 1,

  /**
   * Archive a resource
   *
   * @generated from enum value: ARCHIVE = 2;
   */
  ARCHIVE = 2,

  /**
   * Restore a resource
   *
   * @generated from enum value: RESTORE = 3;
   */
  RESTORE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(LOGBOOK_OPERATION)
proto3.util.setEnumType(LOGBOOK_OPERATION, "Scailo.LOGBOOK_OPERATION", [
  { no: 0, name: "CREATE_UNSPECIFIED" },
  { no: 1, name: "UPDATE" },
  { no: 2, name: "ARCHIVE" },
  { no: 3, name: "RESTORE" },
]);

/**
 *
 * Describes the filter applicable on boolean properties (true, false, or any)
 *
 * @generated from enum Scailo.BOOL_FILTER
 */
export enum BOOL_FILTER {
  /**
   * Disregard the property
   *
   * @generated from enum value: BOOL_FILTER_ANY_UNSPECIFIED = 0;
   */
  BOOL_FILTER_ANY_UNSPECIFIED = 0,

  /**
   * Filter records that have the property set to true
   *
   * @generated from enum value: BOOL_FILTER_TRUE = 1;
   */
  BOOL_FILTER_TRUE = 1,

  /**
   * Filter records that have the property set to false
   *
   * @generated from enum value: BOOL_FILTER_FALSE = 2;
   */
  BOOL_FILTER_FALSE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(BOOL_FILTER)
proto3.util.setEnumType(BOOL_FILTER, "Scailo.BOOL_FILTER", [
  { no: 0, name: "BOOL_FILTER_ANY_UNSPECIFIED" },
  { no: 1, name: "BOOL_FILTER_TRUE" },
  { no: 2, name: "BOOL_FILTER_FALSE" },
]);

/**
 *
 * Describes the lifecycle status of each inventory
 *
 * @generated from enum Scailo.INVENTORY_LIFECYCLE
 */
export enum INVENTORY_LIFECYCLE {
  /**
   * Used only in filters
   *
   * @generated from enum value: INVENTORY_LIFECYCLE_ANY_UNSPECIFIED = 0;
   */
  INVENTORY_LIFECYCLE_ANY_UNSPECIFIED = 0,

  /**
   * Denotes that the inventory is in QC
   *
   * @generated from enum value: INVENTORY_LIFECYCLE_QC = 1;
   */
  INVENTORY_LIFECYCLE_QC = 1,

  /**
   * Denotes that the inventory is in store
   *
   * @generated from enum value: INVENTORY_LIFECYCLE_STORE = 2;
   */
  INVENTORY_LIFECYCLE_STORE = 2,

  /**
   * Denotes that the inventory is in reqork
   *
   * @generated from enum value: INVENTORY_LIFECYCLE_REWORK = 3;
   */
  INVENTORY_LIFECYCLE_REWORK = 3,

  /**
   * Denotes that the inventory has been consumed
   *
   * @generated from enum value: INVENTORY_LIFECYCLE_CONSUMED = 4;
   */
  INVENTORY_LIFECYCLE_CONSUMED = 4,

  /**
   * Denotes that the inventory has been rejected
   *
   * @generated from enum value: INVENTORY_LIFECYCLE_REJECTED = 5;
   */
  INVENTORY_LIFECYCLE_REJECTED = 5,

  /**
   * Denotes that the inventory has been scrapped
   *
   * @generated from enum value: INVENTORY_LIFECYCLE_SCRAP = 6;
   */
  INVENTORY_LIFECYCLE_SCRAP = 6,

  /**
   * Denotes that the inventory is meant to be returned
   *
   * @generated from enum value: INVENTORY_LIFECYCLE_RETURNABLE = 7;
   */
  INVENTORY_LIFECYCLE_RETURNABLE = 7,

  /**
   * Denotes that the inventory has been discarded
   *
   * @generated from enum value: INVENTORY_LIFECYCLE_DISCARDED = 8;
   */
  INVENTORY_LIFECYCLE_DISCARDED = 8,

  /**
   * Denotes that the inventory has been issued
   *
   * @generated from enum value: INVENTORY_LIFECYCLE_ISSUED = 9;
   */
  INVENTORY_LIFECYCLE_ISSUED = 9,
}
// Retrieve enum metadata with: proto3.getEnumType(INVENTORY_LIFECYCLE)
proto3.util.setEnumType(INVENTORY_LIFECYCLE, "Scailo.INVENTORY_LIFECYCLE", [
  { no: 0, name: "INVENTORY_LIFECYCLE_ANY_UNSPECIFIED" },
  { no: 1, name: "INVENTORY_LIFECYCLE_QC" },
  { no: 2, name: "INVENTORY_LIFECYCLE_STORE" },
  { no: 3, name: "INVENTORY_LIFECYCLE_REWORK" },
  { no: 4, name: "INVENTORY_LIFECYCLE_CONSUMED" },
  { no: 5, name: "INVENTORY_LIFECYCLE_REJECTED" },
  { no: 6, name: "INVENTORY_LIFECYCLE_SCRAP" },
  { no: 7, name: "INVENTORY_LIFECYCLE_RETURNABLE" },
  { no: 8, name: "INVENTORY_LIFECYCLE_DISCARDED" },
  { no: 9, name: "INVENTORY_LIFECYCLE_ISSUED" },
]);

/**
 *
 * Describes the available sort keys
 *
 * @generated from enum Scailo.INVENTORY_SORT_KEY
 */
export enum INVENTORY_SORT_KEY {
  /**
   * Fetch ordered results by id
   *
   * @generated from enum value: INVENTORY_SORT_KEY_ID_UNSPECIFIED = 0;
   */
  INVENTORY_SORT_KEY_ID_UNSPECIFIED = 0,

  /**
   * Fetch ordered results by the creation timestamp
   *
   * @generated from enum value: INVENTORY_SORT_KEY_CREATED_AT = 1;
   */
  INVENTORY_SORT_KEY_CREATED_AT = 1,

  /**
   * Fetch ordered results by the modified timestamp
   *
   * @generated from enum value: INVENTORY_SORT_KEY_MODIFIED_AT = 2;
   */
  INVENTORY_SORT_KEY_MODIFIED_AT = 2,

  /**
   * Fetch ordered results by the store intake timestamp
   *
   * @generated from enum value: INVENTORY_SORT_KEY_STORE_INTAKE_AT = 10;
   */
  INVENTORY_SORT_KEY_STORE_INTAKE_AT = 10,

  /**
   * Fetch ordered results by the discarded timestamp
   *
   * @generated from enum value: INVENTORY_SORT_KEY_DISCARDED_AT = 11;
   */
  INVENTORY_SORT_KEY_DISCARDED_AT = 11,

  /**
   * Fetch ordered results by the shelf timestamp
   *
   * @generated from enum value: INVENTORY_SORT_KEY_SHELF_TIMESTAMP = 12;
   */
  INVENTORY_SORT_KEY_SHELF_TIMESTAMP = 12,

  /**
   * Fetch ordered results by the warranty timestamp
   *
   * @generated from enum value: INVENTORY_SORT_KEY_WARRANTY_TIMESTAMP = 13;
   */
  INVENTORY_SORT_KEY_WARRANTY_TIMESTAMP = 13,

  /**
   * Fetch ordered results by the family ID
   *
   * @generated from enum value: INVENTORY_SORT_KEY_FAMILY_ID = 14;
   */
  INVENTORY_SORT_KEY_FAMILY_ID = 14,

  /**
   * Fetch ordered results by the internal item code
   *
   * @generated from enum value: INVENTORY_SORT_KEY_INTERNAL_ITEM_CODE = 20;
   */
  INVENTORY_SORT_KEY_INTERNAL_ITEM_CODE = 20,

  /**
   * Fetch ordered results by the primary quantity
   *
   * @generated from enum value: INVENTORY_SORT_KEY_PRIMARY_QUANTITY = 21;
   */
  INVENTORY_SORT_KEY_PRIMARY_QUANTITY = 21,

  /**
   * Fetch ordered results by the remaining primary quantity
   *
   * @generated from enum value: INVENTORY_SORT_KEY_PRIMARY_QUANTITY_REMAINING = 22;
   */
  INVENTORY_SORT_KEY_PRIMARY_QUANTITY_REMAINING = 22,

  /**
   * Fetch ordered results by the secondary quantity
   *
   * @generated from enum value: INVENTORY_SORT_KEY_SECONDARY_QUANTITY = 23;
   */
  INVENTORY_SORT_KEY_SECONDARY_QUANTITY = 23,

  /**
   * Fetch ordered results by the store ID
   *
   * @generated from enum value: INVENTORY_SORT_KEY_STORE_ID = 24;
   */
  INVENTORY_SORT_KEY_STORE_ID = 24,

  /**
   * Fetch ordered results by the storage ID
   *
   * @generated from enum value: INVENTORY_SORT_KEY_STORAGE_ID = 25;
   */
  INVENTORY_SORT_KEY_STORAGE_ID = 25,
}
// Retrieve enum metadata with: proto3.getEnumType(INVENTORY_SORT_KEY)
proto3.util.setEnumType(INVENTORY_SORT_KEY, "Scailo.INVENTORY_SORT_KEY", [
  { no: 0, name: "INVENTORY_SORT_KEY_ID_UNSPECIFIED" },
  { no: 1, name: "INVENTORY_SORT_KEY_CREATED_AT" },
  { no: 2, name: "INVENTORY_SORT_KEY_MODIFIED_AT" },
  { no: 10, name: "INVENTORY_SORT_KEY_STORE_INTAKE_AT" },
  { no: 11, name: "INVENTORY_SORT_KEY_DISCARDED_AT" },
  { no: 12, name: "INVENTORY_SORT_KEY_SHELF_TIMESTAMP" },
  { no: 13, name: "INVENTORY_SORT_KEY_WARRANTY_TIMESTAMP" },
  { no: 14, name: "INVENTORY_SORT_KEY_FAMILY_ID" },
  { no: 20, name: "INVENTORY_SORT_KEY_INTERNAL_ITEM_CODE" },
  { no: 21, name: "INVENTORY_SORT_KEY_PRIMARY_QUANTITY" },
  { no: 22, name: "INVENTORY_SORT_KEY_PRIMARY_QUANTITY_REMAINING" },
  { no: 23, name: "INVENTORY_SORT_KEY_SECONDARY_QUANTITY" },
  { no: 24, name: "INVENTORY_SORT_KEY_STORE_ID" },
  { no: 25, name: "INVENTORY_SORT_KEY_STORAGE_ID" },
]);

/**
 *
 * Stores all the possible categories of inventory interactions
 *
 * @generated from enum Scailo.INVENTORY_INTERACTION_CATEGORY
 */
export enum INVENTORY_INTERACTION_CATEGORY {
  /**
   * Only used within filter operations
   *
   * @generated from enum value: INVENTORY_INTERACTION_CATEGORY_ANY_UNSPECIFIED = 0;
   */
  INVENTORY_INTERACTION_CATEGORY_ANY_UNSPECIFIED = 0,

  /**
   * Denotes interactions that are classified as issued
   *
   * @generated from enum value: INVENTORY_INTERACTION_CATEGORY_ISSUED = 1;
   */
  INVENTORY_INTERACTION_CATEGORY_ISSUED = 1,

  /**
   * Denotes interactions that are classified as returned
   *
   * @generated from enum value: INVENTORY_INTERACTION_CATEGORY_RETURNED = 2;
   */
  INVENTORY_INTERACTION_CATEGORY_RETURNED = 2,

  /**
   * Denotes interactions that are classified as adjusted
   *
   * @generated from enum value: INVENTORY_INTERACTION_CATEGORY_ADJUSTED = 3;
   */
  INVENTORY_INTERACTION_CATEGORY_ADJUSTED = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(INVENTORY_INTERACTION_CATEGORY)
proto3.util.setEnumType(INVENTORY_INTERACTION_CATEGORY, "Scailo.INVENTORY_INTERACTION_CATEGORY", [
  { no: 0, name: "INVENTORY_INTERACTION_CATEGORY_ANY_UNSPECIFIED" },
  { no: 1, name: "INVENTORY_INTERACTION_CATEGORY_ISSUED" },
  { no: 2, name: "INVENTORY_INTERACTION_CATEGORY_RETURNED" },
  { no: 3, name: "INVENTORY_INTERACTION_CATEGORY_ADJUSTED" },
]);

/**
 *
 * Stores all the possible issued purposes
 *
 * @generated from enum Scailo.INVENTORY_ISSUED_PURPOSE
 */
export enum INVENTORY_ISSUED_PURPOSE {
  /**
   * Only used within filter operations
   *
   * @generated from enum value: INVENTORY_ISSUED_PURPOSE_ANY_UNSPECIFIED = 0;
   */
  INVENTORY_ISSUED_PURPOSE_ANY_UNSPECIFIED = 0,

  /**
   * Issued for Stock Issuance
   *
   * @generated from enum value: INVENTORY_ISSUED_PURPOSE_STOCK_ISSUANCE = 1;
   */
  INVENTORY_ISSUED_PURPOSE_STOCK_ISSUANCE = 1,

  /**
   * Issued for Stock Audit
   *
   * @generated from enum value: INVENTORY_ISSUED_PURPOSE_STOCK_AUDIT = 2;
   */
  INVENTORY_ISSUED_PURPOSE_STOCK_AUDIT = 2,

  /**
   * Issued for Stock Split
   *
   * @generated from enum value: INVENTORY_ISSUED_PURPOSE_STOCK_SPLIT = 3;
   */
  INVENTORY_ISSUED_PURPOSE_STOCK_SPLIT = 3,

  /**
   * Returned using Stock Return
   *
   * @generated from enum value: INVENTORY_ISSUED_PURPOSE_STOCK_RETURN = 4;
   */
  INVENTORY_ISSUED_PURPOSE_STOCK_RETURN = 4,

  /**
   * Issued for Goods Dispatch
   *
   * @generated from enum value: INVENTORY_ISSUED_PURPOSE_GOODS_DISPATCH = 5;
   */
  INVENTORY_ISSUED_PURPOSE_GOODS_DISPATCH = 5,

  /**
   * Issued as intake
   *
   * @generated from enum value: INVENTORY_ISSUED_PURPOSE_INTAKE = 6;
   */
  INVENTORY_ISSUED_PURPOSE_INTAKE = 6,

  /**
   * Initial Stock
   *
   * @generated from enum value: INVENTORY_ISSUED_PURPOSE_INITIAL_STOCK = 7;
   */
  INVENTORY_ISSUED_PURPOSE_INITIAL_STOCK = 7,

  /**
   * Returned using Sales Return
   *
   * @generated from enum value: INVENTORY_ISSUED_PURPOSE_SALES_RETURN = 8;
   */
  INVENTORY_ISSUED_PURPOSE_SALES_RETURN = 8,

  /**
   * Returned using Purchase Return
   *
   * @generated from enum value: INVENTORY_ISSUED_PURPOSE_PURCHASE_RETURN = 9;
   */
  INVENTORY_ISSUED_PURPOSE_PURCHASE_RETURN = 9,

  /**
   * Issued for Outward Job Free Issue Material
   *
   * @generated from enum value: INVENTORY_ISSUED_PURPOSE_OUTWARD_JOB_FREE_ISSUE_MATERIAL = 10;
   */
  INVENTORY_ISSUED_PURPOSE_OUTWARD_JOB_FREE_ISSUE_MATERIAL = 10,

  /**
   * Returned using Outward Job Free Issue Material Return
   *
   * @generated from enum value: INVENTORY_ISSUED_PURPOSE_OUTWARD_JOB_FREE_ISSUE_MATERIAL_RETURN = 11;
   */
  INVENTORY_ISSUED_PURPOSE_OUTWARD_JOB_FREE_ISSUE_MATERIAL_RETURN = 11,

  /**
   * Issued for Inward Job Free Issue Material Return
   *
   * @generated from enum value: INVENTORY_ISSUED_PURPOSE_INWARD_JOB_FREE_ISSUE_MATERIAL_RETURN = 12;
   */
  INVENTORY_ISSUED_PURPOSE_INWARD_JOB_FREE_ISSUE_MATERIAL_RETURN = 12,
}
// Retrieve enum metadata with: proto3.getEnumType(INVENTORY_ISSUED_PURPOSE)
proto3.util.setEnumType(INVENTORY_ISSUED_PURPOSE, "Scailo.INVENTORY_ISSUED_PURPOSE", [
  { no: 0, name: "INVENTORY_ISSUED_PURPOSE_ANY_UNSPECIFIED" },
  { no: 1, name: "INVENTORY_ISSUED_PURPOSE_STOCK_ISSUANCE" },
  { no: 2, name: "INVENTORY_ISSUED_PURPOSE_STOCK_AUDIT" },
  { no: 3, name: "INVENTORY_ISSUED_PURPOSE_STOCK_SPLIT" },
  { no: 4, name: "INVENTORY_ISSUED_PURPOSE_STOCK_RETURN" },
  { no: 5, name: "INVENTORY_ISSUED_PURPOSE_GOODS_DISPATCH" },
  { no: 6, name: "INVENTORY_ISSUED_PURPOSE_INTAKE" },
  { no: 7, name: "INVENTORY_ISSUED_PURPOSE_INITIAL_STOCK" },
  { no: 8, name: "INVENTORY_ISSUED_PURPOSE_SALES_RETURN" },
  { no: 9, name: "INVENTORY_ISSUED_PURPOSE_PURCHASE_RETURN" },
  { no: 10, name: "INVENTORY_ISSUED_PURPOSE_OUTWARD_JOB_FREE_ISSUE_MATERIAL" },
  { no: 11, name: "INVENTORY_ISSUED_PURPOSE_OUTWARD_JOB_FREE_ISSUE_MATERIAL_RETURN" },
  { no: 12, name: "INVENTORY_ISSUED_PURPOSE_INWARD_JOB_FREE_ISSUE_MATERIAL_RETURN" },
]);

/**
 *
 * Stores the possible values of an amendment log reference
 *
 * @generated from enum Scailo.AMENDMENT_LOG_REF_FOR
 */
export enum AMENDMENT_LOG_REF_FOR {
  /**
   * Only used for filter operations
   *
   * @generated from enum value: AMENDMENT_LOG_REF_FOR_ANY_UNSPECIFIED = 0;
   */
  AMENDMENT_LOG_REF_FOR_ANY_UNSPECIFIED = 0,

  /**
   * Denotes that the log is made while amending a family
   *
   * @generated from enum value: AMENDMENT_LOG_REF_FOR_FAMILY = 1;
   */
  AMENDMENT_LOG_REF_FOR_FAMILY = 1,

  /**
   * Denotes that the log is made while amending a purchase order
   *
   * @generated from enum value: AMENDMENT_LOG_REF_FOR_PURCHASE_ORDER = 2;
   */
  AMENDMENT_LOG_REF_FOR_PURCHASE_ORDER = 2,

  /**
   * Denotes that the log is made while amending a supply offer
   *
   * @generated from enum value: AMENDMENT_LOG_REF_FOR_SUPPLY_OFFER = 21;
   */
  AMENDMENT_LOG_REF_FOR_SUPPLY_OFFER = 21,

  /**
   * Denotes that the log is made while amending a sales order
   *
   * @generated from enum value: AMENDMENT_LOG_REF_FOR_SALES_ORDER = 3;
   */
  AMENDMENT_LOG_REF_FOR_SALES_ORDER = 3,

  /**
   * Denotes that the log is made while amending a sales enquiry
   *
   * @generated from enum value: AMENDMENT_LOG_REF_FOR_SALES_ENQUIRY = 4;
   */
  AMENDMENT_LOG_REF_FOR_SALES_ENQUIRY = 4,

  /**
   * Denotes that the log is made while amending a sales quotation
   *
   * @generated from enum value: AMENDMENT_LOG_REF_FOR_SALES_QUOTATION = 5;
   */
  AMENDMENT_LOG_REF_FOR_SALES_QUOTATION = 5,

  /**
   * Denotes that the log is made while amending a sales invoice
   *
   * @generated from enum value: AMENDMENT_LOG_REF_FOR_SALES_INVOICE = 6;
   */
  AMENDMENT_LOG_REF_FOR_SALES_INVOICE = 6,

  /**
   * Denotes that the log is made while amending a proforma invoice
   *
   * @generated from enum value: AMENDMENT_LOG_REF_FOR_PROFORMA_INVOICE = 7;
   */
  AMENDMENT_LOG_REF_FOR_PROFORMA_INVOICE = 7,
}
// Retrieve enum metadata with: proto3.getEnumType(AMENDMENT_LOG_REF_FOR)
proto3.util.setEnumType(AMENDMENT_LOG_REF_FOR, "Scailo.AMENDMENT_LOG_REF_FOR", [
  { no: 0, name: "AMENDMENT_LOG_REF_FOR_ANY_UNSPECIFIED" },
  { no: 1, name: "AMENDMENT_LOG_REF_FOR_FAMILY" },
  { no: 2, name: "AMENDMENT_LOG_REF_FOR_PURCHASE_ORDER" },
  { no: 21, name: "AMENDMENT_LOG_REF_FOR_SUPPLY_OFFER" },
  { no: 3, name: "AMENDMENT_LOG_REF_FOR_SALES_ORDER" },
  { no: 4, name: "AMENDMENT_LOG_REF_FOR_SALES_ENQUIRY" },
  { no: 5, name: "AMENDMENT_LOG_REF_FOR_SALES_QUOTATION" },
  { no: 6, name: "AMENDMENT_LOG_REF_FOR_SALES_INVOICE" },
  { no: 7, name: "AMENDMENT_LOG_REF_FOR_PROFORMA_INVOICE" },
]);

/**
 *
 * Describes an empty object
 *
 * @generated from message Scailo.Empty
 */
export class Empty extends Message<Empty> {
  constructor(data?: PartialMessage<Empty>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.Empty";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Empty {
    return new Empty().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Empty {
    return new Empty().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Empty {
    return new Empty().fromJsonString(jsonString, options);
  }

  static equals(a: Empty | PlainMessage<Empty> | undefined, b: Empty | PlainMessage<Empty> | undefined): boolean {
    return proto3.util.equals(Empty, a, b);
  }
}

/**
 *
 * Describes the boolean response
 *
 * @generated from message Scailo.BooleanResponse
 */
export class BooleanResponse extends Message<BooleanResponse> {
  /**
   * Stores if the value is true or false
   *
   * @generated from field: bool value = 1;
   */
  value = false;

  constructor(data?: PartialMessage<BooleanResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.BooleanResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BooleanResponse {
    return new BooleanResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BooleanResponse {
    return new BooleanResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BooleanResponse {
    return new BooleanResponse().fromJsonString(jsonString, options);
  }

  static equals(a: BooleanResponse | PlainMessage<BooleanResponse> | undefined, b: BooleanResponse | PlainMessage<BooleanResponse> | undefined): boolean {
    return proto3.util.equals(BooleanResponse, a, b);
  }
}

/**
 *
 * Describes a generic response that consists of bytes as payload
 *
 * @generated from message Scailo.BytesResponse
 */
export class BytesResponse extends Message<BytesResponse> {
  /**
   * Stores the response content in bytes
   *
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<BytesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.BytesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BytesResponse {
    return new BytesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BytesResponse {
    return new BytesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BytesResponse {
    return new BytesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: BytesResponse | PlainMessage<BytesResponse> | undefined, b: BytesResponse | PlainMessage<BytesResponse> | undefined): boolean {
    return proto3.util.equals(BytesResponse, a, b);
  }
}

/**
 *
 * Describes a generic response that consists of string as payload
 *
 * @generated from message Scailo.StringResponse
 */
export class StringResponse extends Message<StringResponse> {
  /**
   * Stores the reponse content in string
   *
   * @generated from field: string value = 1;
   */
  value = "";

  constructor(data?: PartialMessage<StringResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.StringResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringResponse {
    return new StringResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringResponse {
    return new StringResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringResponse {
    return new StringResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StringResponse | PlainMessage<StringResponse> | undefined, b: StringResponse | PlainMessage<StringResponse> | undefined): boolean {
    return proto3.util.equals(StringResponse, a, b);
  }
}

/**
 *
 * Describes a generic response that consists of price as payload
 *
 * @generated from message Scailo.PriceResponse
 */
export class PriceResponse extends Message<PriceResponse> {
  /**
   * Stores the price as an integer (in cents)
   *
   * @generated from field: int64 value = 1;
   */
  value = protoInt64.zero;

  constructor(data?: PartialMessage<PriceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.PriceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PriceResponse {
    return new PriceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PriceResponse {
    return new PriceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PriceResponse {
    return new PriceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PriceResponse | PlainMessage<PriceResponse> | undefined, b: PriceResponse | PlainMessage<PriceResponse> | undefined): boolean {
    return proto3.util.equals(PriceResponse, a, b);
  }
}

/**
 *
 * Describes a generic response that consists of info of an image
 *
 * @generated from message Scailo.ImageResponse
 */
export class ImageResponse extends Message<ImageResponse> {
  /**
   * Stores the raw image content
   *
   * @generated from field: bytes image = 1;
   */
  image = new Uint8Array(0);

  /**
   * Stores the MIME type of the image
   *
   * @generated from field: string mime_type = 2;
   */
  mimeType = "";

  /**
   * The timestamp of when the image was captured
   *
   * @generated from field: uint64 timestamp = 3;
   */
  timestamp = protoInt64.zero;

  constructor(data?: PartialMessage<ImageResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.ImageResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "image", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "mime_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "timestamp", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImageResponse {
    return new ImageResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImageResponse {
    return new ImageResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImageResponse {
    return new ImageResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ImageResponse | PlainMessage<ImageResponse> | undefined, b: ImageResponse | PlainMessage<ImageResponse> | undefined): boolean {
    return proto3.util.equals(ImageResponse, a, b);
  }
}

/**
 *
 * Describes the message that consists of a base64 string. Useful for relaying an image as a base64 string.
 *
 * @generated from message Scailo.Base64String
 */
export class Base64String extends Message<Base64String> {
  /**
   * Stores the image as a base64 string
   *
   * @generated from field: string image = 1;
   */
  image = "";

  constructor(data?: PartialMessage<Base64String>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.Base64String";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "image", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Base64String {
    return new Base64String().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Base64String {
    return new Base64String().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Base64String {
    return new Base64String().fromJsonString(jsonString, options);
  }

  static equals(a: Base64String | PlainMessage<Base64String> | undefined, b: Base64String | PlainMessage<Base64String> | undefined): boolean {
    return proto3.util.equals(Base64String, a, b);
  }
}

/**
 *
 * Describes the payload that will be used to filter records on the basis of the given month and day
 *
 * @generated from message Scailo.MonthAndDayFilter
 */
export class MonthAndDayFilter extends Message<MonthAndDayFilter> {
  /**
   * Stores the month (1 for Jan, 2 for Feb, etc.)
   *
   * @generated from field: uint64 month = 1;
   */
  month = protoInt64.zero;

  /**
   * Stores the day
   *
   * @generated from field: uint64 day = 2;
   */
  day = protoInt64.zero;

  constructor(data?: PartialMessage<MonthAndDayFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.MonthAndDayFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "month", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "day", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MonthAndDayFilter {
    return new MonthAndDayFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MonthAndDayFilter {
    return new MonthAndDayFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MonthAndDayFilter {
    return new MonthAndDayFilter().fromJsonString(jsonString, options);
  }

  static equals(a: MonthAndDayFilter | PlainMessage<MonthAndDayFilter> | undefined, b: MonthAndDayFilter | PlainMessage<MonthAndDayFilter> | undefined): boolean {
    return proto3.util.equals(MonthAndDayFilter, a, b);
  }
}

/**
 *
 * Describes a generic response that represents a GPS coordinate
 *
 * @generated from message Scailo.GPSCoordinatesResponse
 */
export class GPSCoordinatesResponse extends Message<GPSCoordinatesResponse> {
  /**
   * Stores the latitude
   *
   * @generated from field: double latitude = 1;
   */
  latitude = 0;

  /**
   * Stores the longitude
   *
   * @generated from field: double longitude = 2;
   */
  longitude = 0;

  constructor(data?: PartialMessage<GPSCoordinatesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.GPSCoordinatesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "latitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "longitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GPSCoordinatesResponse {
    return new GPSCoordinatesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GPSCoordinatesResponse {
    return new GPSCoordinatesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GPSCoordinatesResponse {
    return new GPSCoordinatesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GPSCoordinatesResponse | PlainMessage<GPSCoordinatesResponse> | undefined, b: GPSCoordinatesResponse | PlainMessage<GPSCoordinatesResponse> | undefined): boolean {
    return proto3.util.equals(GPSCoordinatesResponse, a, b);
  }
}

/**
 *
 * Describes the payload for a request to determine the count of records in the given status
 *
 * @generated from message Scailo.CountInSLCStatusRequest
 */
export class CountInSLCStatusRequest extends Message<CountInSLCStatusRequest> {
  /**
   * Denote if only active records need to be returned
   *
   * @generated from field: Scailo.BOOL_FILTER is_active = 1;
   */
  isActive = BOOL_FILTER.BOOL_FILTER_ANY_UNSPECIFIED;

  /**
   * The standard lifecycle status
   *
   * @generated from field: Scailo.STANDARD_LIFECYCLE_STATUS status = 2;
   */
  status = STANDARD_LIFECYCLE_STATUS.ANY_UNSPECIFIED;

  constructor(data?: PartialMessage<CountInSLCStatusRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.CountInSLCStatusRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_active", kind: "enum", T: proto3.getEnumType(BOOL_FILTER) },
    { no: 2, name: "status", kind: "enum", T: proto3.getEnumType(STANDARD_LIFECYCLE_STATUS) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountInSLCStatusRequest {
    return new CountInSLCStatusRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountInSLCStatusRequest {
    return new CountInSLCStatusRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountInSLCStatusRequest {
    return new CountInSLCStatusRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CountInSLCStatusRequest | PlainMessage<CountInSLCStatusRequest> | undefined, b: CountInSLCStatusRequest | PlainMessage<CountInSLCStatusRequest> | undefined): boolean {
    return proto3.util.equals(CountInSLCStatusRequest, a, b);
  }
}

/**
 *
 * Describes the count response
 *
 * @generated from message Scailo.CountResponse
 */
export class CountResponse extends Message<CountResponse> {
  /**
   * The number of records
   *
   * @generated from field: uint64 count = 1;
   */
  count = protoInt64.zero;

  constructor(data?: PartialMessage<CountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.CountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountResponse {
    return new CountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountResponse {
    return new CountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountResponse {
    return new CountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CountResponse | PlainMessage<CountResponse> | undefined, b: CountResponse | PlainMessage<CountResponse> | undefined): boolean {
    return proto3.util.equals(CountResponse, a, b);
  }
}

/**
 *
 * Describes the sum reponse
 *
 * @generated from message Scailo.SumResponse
 */
export class SumResponse extends Message<SumResponse> {
  /**
   * The sum of all the records
   *
   * @generated from field: double sum = 1;
   */
  sum = 0;

  constructor(data?: PartialMessage<SumResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.SumResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sum", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SumResponse {
    return new SumResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SumResponse {
    return new SumResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SumResponse {
    return new SumResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SumResponse | PlainMessage<SumResponse> | undefined, b: SumResponse | PlainMessage<SumResponse> | undefined): boolean {
    return proto3.util.equals(SumResponse, a, b);
  }
}

/**
 *
 * Describes the quantity response
 *
 * @generated from message Scailo.QuantityResponse
 */
export class QuantityResponse extends Message<QuantityResponse> {
  /**
   * The quantity (has to be int currently, since certain locations might need negative values, such as "required quantity" responses)
   *
   * @generated from field: int64 quantity = 1;
   */
  quantity = protoInt64.zero;

  constructor(data?: PartialMessage<QuantityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.QuantityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "quantity", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuantityResponse {
    return new QuantityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuantityResponse {
    return new QuantityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuantityResponse {
    return new QuantityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QuantityResponse | PlainMessage<QuantityResponse> | undefined, b: QuantityResponse | PlainMessage<QuantityResponse> | undefined): boolean {
    return proto3.util.equals(QuantityResponse, a, b);
  }
}

/**
 *
 * Describes the dual quantity response. Primary quantity represents quantity in internal UoM and secondary quantity represents quantity in either vendor UoM or client UoM, depending on the context
 *
 * @generated from message Scailo.DualQuantitiesResponse
 */
export class DualQuantitiesResponse extends Message<DualQuantitiesResponse> {
  /**
   * Quantity in internal UoM
   *
   * @generated from field: uint64 primary_quantity = 1;
   */
  primaryQuantity = protoInt64.zero;

  /**
   * Quantity in either vendor or client UoM
   *
   * @generated from field: uint64 secondary_quantity = 2;
   */
  secondaryQuantity = protoInt64.zero;

  constructor(data?: PartialMessage<DualQuantitiesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.DualQuantitiesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "primary_quantity", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "secondary_quantity", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DualQuantitiesResponse {
    return new DualQuantitiesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DualQuantitiesResponse {
    return new DualQuantitiesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DualQuantitiesResponse {
    return new DualQuantitiesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DualQuantitiesResponse | PlainMessage<DualQuantitiesResponse> | undefined, b: DualQuantitiesResponse | PlainMessage<DualQuantitiesResponse> | undefined): boolean {
    return proto3.util.equals(DualQuantitiesResponse, a, b);
  }
}

/**
 *
 * Describes the employee metadata of each resource
 *
 * @generated from message Scailo.EmployeeMetadata
 */
export class EmployeeMetadata extends Message<EmployeeMetadata> {
  /**
   * ID of the resource
   *
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * UUID of the resource
   *
   * @generated from field: string uuid = 2;
   */
  uuid = "";

  /**
   * Stores the username of the user who added this resource
   *
   * @generated from field: string added_by = 3;
   */
  addedBy = "";

  /**
   * Represents if the resource is active
   *
   * @generated from field: bool is_active = 4;
   */
  isActive = false;

  /**
   * Stores the timestamp of when the resource was created
   *
   * @generated from field: uint64 created_at = 5;
   */
  createdAt = protoInt64.zero;

  /**
   * Stores the timestamp of when the resource was last modified
   *
   * @generated from field: uint64 modified_at = 6;
   */
  modifiedAt = protoInt64.zero;

  constructor(data?: PartialMessage<EmployeeMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.EmployeeMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "added_by", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "is_active", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "created_at", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "modified_at", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EmployeeMetadata {
    return new EmployeeMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EmployeeMetadata {
    return new EmployeeMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EmployeeMetadata {
    return new EmployeeMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: EmployeeMetadata | PlainMessage<EmployeeMetadata> | undefined, b: EmployeeMetadata | PlainMessage<EmployeeMetadata> | undefined): boolean {
    return proto3.util.equals(EmployeeMetadata, a, b);
  }
}

/**
 *
 * Describes the approval metadata of each resource
 *
 * @generated from message Scailo.ApprovalMetadata
 */
export class ApprovalMetadata extends Message<ApprovalMetadata> {
  /**
   * Stores the UNIX timestamp of when a resource was approved
   *
   * @generated from field: uint64 approved_on = 1;
   */
  approvedOn = protoInt64.zero;

  /**
   * Stores the ID of the user who approved this resource
   *
   * @generated from field: uint64 approved_by_user_id = 2;
   */
  approvedByUserId = protoInt64.zero;

  /**
   * Stores the Role ID of the user who approved this resource at the time of approval. This needs to be stored, as the user's role is fluid
   *
   * @generated from field: uint64 approver_role_id = 3;
   */
  approverRoleId = protoInt64.zero;

  constructor(data?: PartialMessage<ApprovalMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.ApprovalMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "approved_on", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "approved_by_user_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "approver_role_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApprovalMetadata {
    return new ApprovalMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApprovalMetadata {
    return new ApprovalMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApprovalMetadata {
    return new ApprovalMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: ApprovalMetadata | PlainMessage<ApprovalMetadata> | undefined, b: ApprovalMetadata | PlainMessage<ApprovalMetadata> | undefined): boolean {
    return proto3.util.equals(ApprovalMetadata, a, b);
  }
}

/**
 *
 * Describes the status of the records returned to a request
 *
 * @generated from message Scailo.ActiveStatus
 */
export class ActiveStatus extends Message<ActiveStatus> {
  /**
   * Used in ViewAll procedural calls, to denote if only active records need to be returned
   *
   * @generated from field: Scailo.BOOL_FILTER is_active = 1;
   */
  isActive = BOOL_FILTER.BOOL_FILTER_ANY_UNSPECIFIED;

  constructor(data?: PartialMessage<ActiveStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.ActiveStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_active", kind: "enum", T: proto3.getEnumType(BOOL_FILTER) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActiveStatus {
    return new ActiveStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActiveStatus {
    return new ActiveStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActiveStatus {
    return new ActiveStatus().fromJsonString(jsonString, options);
  }

  static equals(a: ActiveStatus | PlainMessage<ActiveStatus> | undefined, b: ActiveStatus | PlainMessage<ActiveStatus> | undefined): boolean {
    return proto3.util.equals(ActiveStatus, a, b);
  }
}

/**
 *
 * Describes the payload that is required to update the password of a user (by an administrator)
 *
 * @generated from message Scailo.UpdatePasswordReq
 */
export class UpdatePasswordReq extends Message<UpdatePasswordReq> {
  /**
   * Stores any comment that the user might add during this operation
   *
   * @generated from field: string user_comment = 1;
   */
  userComment = "";

  /**
   * The ID of the record that needs to be updated
   *
   * @generated from field: uint64 id = 2;
   */
  id = protoInt64.zero;

  /**
   * The plain text password using which the user can login
   *
   * @generated from field: string plain_text_password = 10;
   */
  plainTextPassword = "";

  constructor(data?: PartialMessage<UpdatePasswordReq>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.UpdatePasswordReq";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 10, name: "plain_text_password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdatePasswordReq {
    return new UpdatePasswordReq().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdatePasswordReq {
    return new UpdatePasswordReq().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdatePasswordReq {
    return new UpdatePasswordReq().fromJsonString(jsonString, options);
  }

  static equals(a: UpdatePasswordReq | PlainMessage<UpdatePasswordReq> | undefined, b: UpdatePasswordReq | PlainMessage<UpdatePasswordReq> | undefined): boolean {
    return proto3.util.equals(UpdatePasswordReq, a, b);
  }
}

/**
 *
 * Describes the payload that is requred to update the user's own password
 *
 * @generated from message Scailo.UpdateOwnPasswordReq
 */
export class UpdateOwnPasswordReq extends Message<UpdateOwnPasswordReq> {
  /**
   * Stores any comment that the user might add during this operation
   *
   * @generated from field: string user_comment = 1;
   */
  userComment = "";

  /**
   * The old login password
   *
   * @generated from field: string old_plain_text_password = 3;
   */
  oldPlainTextPassword = "";

  /**
   * The new password
   *
   * @generated from field: string plain_text_password = 4;
   */
  plainTextPassword = "";

  constructor(data?: PartialMessage<UpdateOwnPasswordReq>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.UpdateOwnPasswordReq";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "old_plain_text_password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "plain_text_password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateOwnPasswordReq {
    return new UpdateOwnPasswordReq().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateOwnPasswordReq {
    return new UpdateOwnPasswordReq().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateOwnPasswordReq {
    return new UpdateOwnPasswordReq().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateOwnPasswordReq | PlainMessage<UpdateOwnPasswordReq> | undefined, b: UpdateOwnPasswordReq | PlainMessage<UpdateOwnPasswordReq> | undefined): boolean {
    return proto3.util.equals(UpdateOwnPasswordReq, a, b);
  }
}

/**
 *
 * Describes the payload that is required to upload a picture associated to a resource (such as profile picture or signature)
 *
 * @generated from message Scailo.UploadPictureReq
 */
export class UploadPictureReq extends Message<UploadPictureReq> {
  /**
   * Stores any comment that the user might add during this operation
   *
   * @generated from field: string user_comment = 1;
   */
  userComment = "";

  /**
   * The ID of the record that needs to be updated
   *
   * @generated from field: uint64 id = 2;
   */
  id = protoInt64.zero;

  /**
   * The base64 encoded image that is to be set as the profile picture
   *
   * @generated from field: string img = 10;
   */
  img = "";

  /**
   * The MIME type of the profile picture
   *
   * @generated from field: string mime_type = 11;
   */
  mimeType = "";

  constructor(data?: PartialMessage<UploadPictureReq>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.UploadPictureReq";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 10, name: "img", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "mime_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UploadPictureReq {
    return new UploadPictureReq().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UploadPictureReq {
    return new UploadPictureReq().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UploadPictureReq {
    return new UploadPictureReq().fromJsonString(jsonString, options);
  }

  static equals(a: UploadPictureReq | PlainMessage<UploadPictureReq> | undefined, b: UploadPictureReq | PlainMessage<UploadPictureReq> | undefined): boolean {
    return proto3.util.equals(UploadPictureReq, a, b);
  }
}

/**
 *
 * Describes a simple search request
 *
 * @generated from message Scailo.SimpleSearchReq
 */
export class SimpleSearchReq extends Message<SimpleSearchReq> {
  /**
   * @generated from field: string search_key = 1;
   */
  searchKey = "";

  constructor(data?: PartialMessage<SimpleSearchReq>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.SimpleSearchReq";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "search_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SimpleSearchReq {
    return new SimpleSearchReq().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SimpleSearchReq {
    return new SimpleSearchReq().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SimpleSearchReq {
    return new SimpleSearchReq().fromJsonString(jsonString, options);
  }

  static equals(a: SimpleSearchReq | PlainMessage<SimpleSearchReq> | undefined, b: SimpleSearchReq | PlainMessage<SimpleSearchReq> | undefined): boolean {
    return proto3.util.equals(SimpleSearchReq, a, b);
  }
}

/**
 *
 * Describes the payload necessary for performing Repeat requests with a specific delivery date
 *
 * @generated from message Scailo.RepeatWithDeliveryDate
 */
export class RepeatWithDeliveryDate extends Message<RepeatWithDeliveryDate> {
  /**
   * ID of the resource
   *
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * Stores any comment that the user might add during this operation
   *
   * @generated from field: string user_comment = 2;
   */
  userComment = "";

  /**
   * The reference ID of the repeated record
   *
   * @generated from field: string reference_id = 10;
   */
  referenceId = "";

  /**
   * The common delivery date
   *
   * @generated from field: string delivery_date = 13;
   */
  deliveryDate = "";

  constructor(data?: PartialMessage<RepeatWithDeliveryDate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.RepeatWithDeliveryDate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "user_comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "reference_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "delivery_date", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatWithDeliveryDate {
    return new RepeatWithDeliveryDate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatWithDeliveryDate {
    return new RepeatWithDeliveryDate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatWithDeliveryDate {
    return new RepeatWithDeliveryDate().fromJsonString(jsonString, options);
  }

  static equals(a: RepeatWithDeliveryDate | PlainMessage<RepeatWithDeliveryDate> | undefined, b: RepeatWithDeliveryDate | PlainMessage<RepeatWithDeliveryDate> | undefined): boolean {
    return proto3.util.equals(RepeatWithDeliveryDate, a, b);
  }
}

/**
 *
 * Describes the standard identifier
 *
 * @generated from message Scailo.Identifier
 */
export class Identifier extends Message<Identifier> {
  /**
   * ID of the resource
   *
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  constructor(data?: PartialMessage<Identifier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.Identifier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Identifier {
    return new Identifier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Identifier {
    return new Identifier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Identifier {
    return new Identifier().fromJsonString(jsonString, options);
  }

  static equals(a: Identifier | PlainMessage<Identifier> | undefined, b: Identifier | PlainMessage<Identifier> | undefined): boolean {
    return proto3.util.equals(Identifier, a, b);
  }
}

/**
 *
 * Describes the response that consists of the ID and the UUID of the record
 *
 * @generated from message Scailo.IdentifierResponse
 */
export class IdentifierResponse extends Message<IdentifierResponse> {
  /**
   * ID of the resource
   *
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * UUID of the resource
   *
   * @generated from field: string uuid = 10;
   */
  uuid = "";

  constructor(data?: PartialMessage<IdentifierResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.IdentifierResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 10, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdentifierResponse {
    return new IdentifierResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdentifierResponse {
    return new IdentifierResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdentifierResponse {
    return new IdentifierResponse().fromJsonString(jsonString, options);
  }

  static equals(a: IdentifierResponse | PlainMessage<IdentifierResponse> | undefined, b: IdentifierResponse | PlainMessage<IdentifierResponse> | undefined): boolean {
    return proto3.util.equals(IdentifierResponse, a, b);
  }
}

/**
 *
 * Describes the standard identifier that can also be a zero
 *
 * @generated from message Scailo.IdentifierZeroable
 */
export class IdentifierZeroable extends Message<IdentifierZeroable> {
  /**
   * ID of the resource
   *
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  constructor(data?: PartialMessage<IdentifierZeroable>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.IdentifierZeroable";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdentifierZeroable {
    return new IdentifierZeroable().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdentifierZeroable {
    return new IdentifierZeroable().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdentifierZeroable {
    return new IdentifierZeroable().fromJsonString(jsonString, options);
  }

  static equals(a: IdentifierZeroable | PlainMessage<IdentifierZeroable> | undefined, b: IdentifierZeroable | PlainMessage<IdentifierZeroable> | undefined): boolean {
    return proto3.util.equals(IdentifierZeroable, a, b);
  }
}

/**
 *
 * Describes the standard identifier along with a search key
 *
 * @generated from message Scailo.IdentifierWithSearch
 */
export class IdentifierWithSearch extends Message<IdentifierWithSearch> {
  /**
   * ID of the resource
   *
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * Describes the key with which the search operation needs to be performed
   *
   * @generated from field: string search_key = 2;
   */
  searchKey = "";

  constructor(data?: PartialMessage<IdentifierWithSearch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.IdentifierWithSearch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "search_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdentifierWithSearch {
    return new IdentifierWithSearch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdentifierWithSearch {
    return new IdentifierWithSearch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdentifierWithSearch {
    return new IdentifierWithSearch().fromJsonString(jsonString, options);
  }

  static equals(a: IdentifierWithSearch | PlainMessage<IdentifierWithSearch> | undefined, b: IdentifierWithSearch | PlainMessage<IdentifierWithSearch> | undefined): boolean {
    return proto3.util.equals(IdentifierWithSearch, a, b);
  }
}

/**
 *
 * Describes the list of standard identifiers, used for identifying associated items
 *
 * @generated from message Scailo.IdentifiersList
 */
export class IdentifiersList extends Message<IdentifiersList> {
  /**
   * List of identifiers
   *
   * @generated from field: repeated uint64 list = 1;
   */
  list: bigint[] = [];

  constructor(data?: PartialMessage<IdentifiersList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.IdentifiersList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "list", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdentifiersList {
    return new IdentifiersList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdentifiersList {
    return new IdentifiersList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdentifiersList {
    return new IdentifiersList().fromJsonString(jsonString, options);
  }

  static equals(a: IdentifiersList | PlainMessage<IdentifiersList> | undefined, b: IdentifiersList | PlainMessage<IdentifiersList> | undefined): boolean {
    return proto3.util.equals(IdentifiersList, a, b);
  }
}

/**
 *
 * Describes the list of simple strings, used for underlying associated items
 *
 * @generated from message Scailo.StringsList
 */
export class StringsList extends Message<StringsList> {
  /**
   * List of strings
   *
   * @generated from field: repeated string list = 1;
   */
  list: string[] = [];

  constructor(data?: PartialMessage<StringsList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.StringsList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "list", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringsList {
    return new StringsList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringsList {
    return new StringsList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringsList {
    return new StringsList().fromJsonString(jsonString, options);
  }

  static equals(a: StringsList | PlainMessage<StringsList> | undefined, b: StringsList | PlainMessage<StringsList> | undefined): boolean {
    return proto3.util.equals(StringsList, a, b);
  }
}

/**
 *
 * Describes the standard identifier with a user comment. Useful when an operation needs to be performed, and a user comment needs to be recorded
 *
 * @generated from message Scailo.IdentifierWithUserComment
 */
export class IdentifierWithUserComment extends Message<IdentifierWithUserComment> {
  /**
   * ID of the resource
   *
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * Stores any comment that the user might add during this operation
   *
   * @generated from field: string user_comment = 2;
   */
  userComment = "";

  constructor(data?: PartialMessage<IdentifierWithUserComment>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.IdentifierWithUserComment";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "user_comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdentifierWithUserComment {
    return new IdentifierWithUserComment().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdentifierWithUserComment {
    return new IdentifierWithUserComment().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdentifierWithUserComment {
    return new IdentifierWithUserComment().fromJsonString(jsonString, options);
  }

  static equals(a: IdentifierWithUserComment | PlainMessage<IdentifierWithUserComment> | undefined, b: IdentifierWithUserComment | PlainMessage<IdentifierWithUserComment> | undefined): boolean {
    return proto3.util.equals(IdentifierWithUserComment, a, b);
  }
}

/**
 *
 * Describes the standard identifier with email attributes. Useful when a record (identified by the identifier) needs to be mailed with the given subject, and the list of email addresses.
 *
 * @generated from message Scailo.IdentifierWithEmailAttributes
 */
export class IdentifierWithEmailAttributes extends Message<IdentifierWithEmailAttributes> {
  /**
   * ID of the resource
   *
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * The subject of the email
   *
   * @generated from field: string subject = 10;
   */
  subject = "";

  /**
   * The list of email addresses of the recipients
   *
   * @generated from field: repeated string recipients = 11;
   */
  recipients: string[] = [];

  /**
   * The body of the email
   *
   * @generated from field: string body = 12;
   */
  body = "";

  constructor(data?: PartialMessage<IdentifierWithEmailAttributes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.IdentifierWithEmailAttributes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 10, name: "subject", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "recipients", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 12, name: "body", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdentifierWithEmailAttributes {
    return new IdentifierWithEmailAttributes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdentifierWithEmailAttributes {
    return new IdentifierWithEmailAttributes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdentifierWithEmailAttributes {
    return new IdentifierWithEmailAttributes().fromJsonString(jsonString, options);
  }

  static equals(a: IdentifierWithEmailAttributes | PlainMessage<IdentifierWithEmailAttributes> | undefined, b: IdentifierWithEmailAttributes | PlainMessage<IdentifierWithEmailAttributes> | undefined): boolean {
    return proto3.util.equals(IdentifierWithEmailAttributes, a, b);
  }
}

/**
 *
 * Describes the standard identifier with a search key. Useful when searching within sub records of a parent item (such as shift group shifts, etc)
 *
 * @generated from message Scailo.IdentifierWithSearchKey
 */
export class IdentifierWithSearchKey extends Message<IdentifierWithSearchKey> {
  /**
   * ID of the resource
   *
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * The search key
   *
   * @generated from field: string search_key = 2;
   */
  searchKey = "";

  constructor(data?: PartialMessage<IdentifierWithSearchKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.IdentifierWithSearchKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "search_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdentifierWithSearchKey {
    return new IdentifierWithSearchKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdentifierWithSearchKey {
    return new IdentifierWithSearchKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdentifierWithSearchKey {
    return new IdentifierWithSearchKey().fromJsonString(jsonString, options);
  }

  static equals(a: IdentifierWithSearchKey | PlainMessage<IdentifierWithSearchKey> | undefined, b: IdentifierWithSearchKey | PlainMessage<IdentifierWithSearchKey> | undefined): boolean {
    return proto3.util.equals(IdentifierWithSearchKey, a, b);
  }
}

/**
 *
 * Describes the standard identifier with a file. Useful for uploading CSV files to records identified by the identifier
 *
 * @generated from message Scailo.IdentifierWithFile
 */
export class IdentifierWithFile extends Message<IdentifierWithFile> {
  /**
   * ID of the resource
   *
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * The content of the file
   *
   * @generated from field: bytes file_content = 10;
   */
  fileContent = new Uint8Array(0);

  constructor(data?: PartialMessage<IdentifierWithFile>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.IdentifierWithFile";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 10, name: "file_content", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdentifierWithFile {
    return new IdentifierWithFile().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdentifierWithFile {
    return new IdentifierWithFile().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdentifierWithFile {
    return new IdentifierWithFile().fromJsonString(jsonString, options);
  }

  static equals(a: IdentifierWithFile | PlainMessage<IdentifierWithFile> | undefined, b: IdentifierWithFile | PlainMessage<IdentifierWithFile> | undefined): boolean {
    return proto3.util.equals(IdentifierWithFile, a, b);
  }
}

/**
 *
 * Describes the standard UUID identifier with a file. Useful for uploading CSV files to records identified by the identifier UUID
 *
 * @generated from message Scailo.IdentifierUUIDWithFile
 */
export class IdentifierUUIDWithFile extends Message<IdentifierUUIDWithFile> {
  /**
   * UUID of the resource
   *
   * @generated from field: string uuid = 1;
   */
  uuid = "";

  /**
   * The content of the file
   *
   * @generated from field: bytes file_content = 10;
   */
  fileContent = new Uint8Array(0);

  constructor(data?: PartialMessage<IdentifierUUIDWithFile>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.IdentifierUUIDWithFile";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "file_content", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdentifierUUIDWithFile {
    return new IdentifierUUIDWithFile().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdentifierUUIDWithFile {
    return new IdentifierUUIDWithFile().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdentifierUUIDWithFile {
    return new IdentifierUUIDWithFile().fromJsonString(jsonString, options);
  }

  static equals(a: IdentifierUUIDWithFile | PlainMessage<IdentifierUUIDWithFile> | undefined, b: IdentifierUUIDWithFile | PlainMessage<IdentifierUUIDWithFile> | undefined): boolean {
    return proto3.util.equals(IdentifierUUIDWithFile, a, b);
  }
}

/**
 *
 * Describes the UUID identifier
 *
 * @generated from message Scailo.IdentifierUUID
 */
export class IdentifierUUID extends Message<IdentifierUUID> {
  /**
   * UUID of the resource
   *
   * @generated from field: string uuid = 1;
   */
  uuid = "";

  constructor(data?: PartialMessage<IdentifierUUID>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.IdentifierUUID";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdentifierUUID {
    return new IdentifierUUID().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdentifierUUID {
    return new IdentifierUUID().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdentifierUUID {
    return new IdentifierUUID().fromJsonString(jsonString, options);
  }

  static equals(a: IdentifierUUID | PlainMessage<IdentifierUUID> | undefined, b: IdentifierUUID | PlainMessage<IdentifierUUID> | undefined): boolean {
    return proto3.util.equals(IdentifierUUID, a, b);
  }
}

/**
 *
 * Describes the list of UUID identifiers, used for identifying associated items
 *
 * @generated from message Scailo.IdentifierUUIDsList
 */
export class IdentifierUUIDsList extends Message<IdentifierUUIDsList> {
  /**
   * List of UUID identifiers
   *
   * @generated from field: repeated Scailo.IdentifierUUID list = 1;
   */
  list: IdentifierUUID[] = [];

  constructor(data?: PartialMessage<IdentifierUUIDsList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.IdentifierUUIDsList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "list", kind: "message", T: IdentifierUUID, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdentifierUUIDsList {
    return new IdentifierUUIDsList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdentifierUUIDsList {
    return new IdentifierUUIDsList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdentifierUUIDsList {
    return new IdentifierUUIDsList().fromJsonString(jsonString, options);
  }

  static equals(a: IdentifierUUIDsList | PlainMessage<IdentifierUUIDsList> | undefined, b: IdentifierUUIDsList | PlainMessage<IdentifierUUIDsList> | undefined): boolean {
    return proto3.util.equals(IdentifierUUIDsList, a, b);
  }
}

/**
 *
 * Describes each parameter that's part of the logbook (does not include historical data of the object) with the operation being a standard lifecycle status
 *
 * @generated from message Scailo.LogbookLogConciseSLC
 */
export class LogbookLogConciseSLC extends Message<LogbookLogConciseSLC> {
  /**
   * ID of the resource
   *
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * Stores if the resource is active
   *
   * @generated from field: bool is_active = 2;
   */
  isActive = false;

  /**
   * Stores the timestamp of when this resource was created
   *
   * @generated from field: uint64 timestamp = 3;
   */
  timestamp = protoInt64.zero;

  /**
   * The UUID of the resource
   *
   * @generated from field: string ref_uuid = 10;
   */
  refUuid = "";

  /**
   * The operation that was performed
   *
   * @generated from field: Scailo.STANDARD_LIFECYCLE_STATUS operation = 11;
   */
  operation = STANDARD_LIFECYCLE_STATUS.ANY_UNSPECIFIED;

  /**
   * The username of the user who performed this operation
   *
   * @generated from field: string username = 12;
   */
  username = "";

  /**
   * The name of the person who made this entry
   *
   * @generated from field: string name = 13;
   */
  name = "";

  /**
   * The ID of the user who made this entry
   *
   * @generated from field: uint64 user_id = 14;
   */
  userId = protoInt64.zero;

  /**
   * The comment generated by the application
   *
   * @generated from field: string app_comment = 15;
   */
  appComment = "";

  /**
   * The comment entered by the user
   *
   * @generated from field: string user_comment = 16;
   */
  userComment = "";

  constructor(data?: PartialMessage<LogbookLogConciseSLC>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.LogbookLogConciseSLC";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "is_active", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "timestamp", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 10, name: "ref_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "operation", kind: "enum", T: proto3.getEnumType(STANDARD_LIFECYCLE_STATUS) },
    { no: 12, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "user_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 15, name: "app_comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "user_comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogbookLogConciseSLC {
    return new LogbookLogConciseSLC().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogbookLogConciseSLC {
    return new LogbookLogConciseSLC().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogbookLogConciseSLC {
    return new LogbookLogConciseSLC().fromJsonString(jsonString, options);
  }

  static equals(a: LogbookLogConciseSLC | PlainMessage<LogbookLogConciseSLC> | undefined, b: LogbookLogConciseSLC | PlainMessage<LogbookLogConciseSLC> | undefined): boolean {
    return proto3.util.equals(LogbookLogConciseSLC, a, b);
  }
}

/**
 *
 * Describes the parameters that are required to create a standard lifecycle log entry
 *
 * @generated from message Scailo.LogbookLogConciseSLCCreateRequest
 */
export class LogbookLogConciseSLCCreateRequest extends Message<LogbookLogConciseSLCCreateRequest> {
  /**
   * Stores the timestamp of when this resource was created
   *
   * @generated from field: uint64 timestamp = 3;
   */
  timestamp = protoInt64.zero;

  /**
   * The UUID of the resource
   *
   * @generated from field: string ref_uuid = 10;
   */
  refUuid = "";

  /**
   * The operation that was performed
   *
   * @generated from field: Scailo.STANDARD_LIFECYCLE_STATUS operation = 11;
   */
  operation = STANDARD_LIFECYCLE_STATUS.ANY_UNSPECIFIED;

  /**
   * The username of the user who performed this operation
   *
   * @generated from field: string username = 12;
   */
  username = "";

  /**
   * The comment generated by the application
   *
   * @generated from field: string app_comment = 13;
   */
  appComment = "";

  /**
   * The comment entered by the user
   *
   * @generated from field: string user_comment = 14;
   */
  userComment = "";

  constructor(data?: PartialMessage<LogbookLogConciseSLCCreateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.LogbookLogConciseSLCCreateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "timestamp", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 10, name: "ref_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "operation", kind: "enum", T: proto3.getEnumType(STANDARD_LIFECYCLE_STATUS) },
    { no: 12, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "app_comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "user_comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogbookLogConciseSLCCreateRequest {
    return new LogbookLogConciseSLCCreateRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogbookLogConciseSLCCreateRequest {
    return new LogbookLogConciseSLCCreateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogbookLogConciseSLCCreateRequest {
    return new LogbookLogConciseSLCCreateRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LogbookLogConciseSLCCreateRequest | PlainMessage<LogbookLogConciseSLCCreateRequest> | undefined, b: LogbookLogConciseSLCCreateRequest | PlainMessage<LogbookLogConciseSLCCreateRequest> | undefined): boolean {
    return proto3.util.equals(LogbookLogConciseSLCCreateRequest, a, b);
  }
}

/**
 *
 * Describes the parameters that are required to create a generic lifecycle log entry
 *
 * @generated from message Scailo.LogbookLogConciseGenericCreateRequest
 */
export class LogbookLogConciseGenericCreateRequest extends Message<LogbookLogConciseGenericCreateRequest> {
  /**
   * Stores the timestamp of when this resource was created
   *
   * @generated from field: uint64 timestamp = 3;
   */
  timestamp = protoInt64.zero;

  /**
   * The UUID of the resource
   *
   * @generated from field: string ref_uuid = 10;
   */
  refUuid = "";

  /**
   * The operation that was performed
   *
   * @generated from field: string operation = 11;
   */
  operation = "";

  /**
   * The username of the user who performed this operation
   *
   * @generated from field: string username = 12;
   */
  username = "";

  /**
   * The comment generated by the application
   *
   * @generated from field: string app_comment = 13;
   */
  appComment = "";

  /**
   * The comment entered by the user
   *
   * @generated from field: string user_comment = 14;
   */
  userComment = "";

  constructor(data?: PartialMessage<LogbookLogConciseGenericCreateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.LogbookLogConciseGenericCreateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "timestamp", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 10, name: "ref_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "operation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "app_comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "user_comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogbookLogConciseGenericCreateRequest {
    return new LogbookLogConciseGenericCreateRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogbookLogConciseGenericCreateRequest {
    return new LogbookLogConciseGenericCreateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogbookLogConciseGenericCreateRequest {
    return new LogbookLogConciseGenericCreateRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LogbookLogConciseGenericCreateRequest | PlainMessage<LogbookLogConciseGenericCreateRequest> | undefined, b: LogbookLogConciseGenericCreateRequest | PlainMessage<LogbookLogConciseGenericCreateRequest> | undefined): boolean {
    return proto3.util.equals(LogbookLogConciseGenericCreateRequest, a, b);
  }
}

/**
 *
 * Describes each parameter that's part of the logbook (includes historical data of the object)
 *
 * @generated from message Scailo.LogbookLogComplete
 */
export class LogbookLogComplete extends Message<LogbookLogComplete> {
  /**
   * Stores the metada of this resource
   *
   * @generated from field: Scailo.EmployeeMetadata metadata = 1;
   */
  metadata?: EmployeeMetadata;

  /**
   * The UUID of the resource
   *
   * @generated from field: string ref_uuid = 10;
   */
  refUuid = "";

  /**
   * The operation that was performed
   *
   * @generated from field: Scailo.LOGBOOK_OPERATION operation = 11;
   */
  operation = LOGBOOK_OPERATION.CREATE_UNSPECIFIED;

  /**
   * The username of the user who performed this operation
   *
   * @generated from field: string username = 12;
   */
  username = "";

  /**
   * The comment generated by the application
   *
   * @generated from field: string app_comment = 13;
   */
  appComment = "";

  /**
   * The comment entered by the user
   *
   * @generated from field: string user_comment = 14;
   */
  userComment = "";

  /**
   * The marshalled object at the time the log was created
   *
   * @generated from field: bytes previous_data = 15;
   */
  previousData = new Uint8Array(0);

  constructor(data?: PartialMessage<LogbookLogComplete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.LogbookLogComplete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: EmployeeMetadata },
    { no: 10, name: "ref_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "operation", kind: "enum", T: proto3.getEnumType(LOGBOOK_OPERATION) },
    { no: 12, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "app_comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "user_comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "previous_data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogbookLogComplete {
    return new LogbookLogComplete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogbookLogComplete {
    return new LogbookLogComplete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogbookLogComplete {
    return new LogbookLogComplete().fromJsonString(jsonString, options);
  }

  static equals(a: LogbookLogComplete | PlainMessage<LogbookLogComplete> | undefined, b: LogbookLogComplete | PlainMessage<LogbookLogComplete> | undefined): boolean {
    return proto3.util.equals(LogbookLogComplete, a, b);
  }
}

/**
 *
 * Describes the data model to handle reordering of items
 *
 * @generated from message Scailo.ReorderItemsRequest
 */
export class ReorderItemsRequest extends Message<ReorderItemsRequest> {
  /**
   * ID of the resource
   *
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * The list of IDs to be stored in the given sequence
   *
   * @generated from field: repeated uint64 sequence = 2;
   */
  sequence: bigint[] = [];

  constructor(data?: PartialMessage<ReorderItemsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.ReorderItemsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "sequence", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReorderItemsRequest {
    return new ReorderItemsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReorderItemsRequest {
    return new ReorderItemsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReorderItemsRequest {
    return new ReorderItemsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReorderItemsRequest | PlainMessage<ReorderItemsRequest> | undefined, b: ReorderItemsRequest | PlainMessage<ReorderItemsRequest> | undefined): boolean {
    return proto3.util.equals(ReorderItemsRequest, a, b);
  }
}

/**
 *
 * Describes the data model to handle cloning of properties of a source record (denoted by source ID) into a target record (denoted by the target ID)
 *
 * @generated from message Scailo.CloneRequest
 */
export class CloneRequest extends Message<CloneRequest> {
  /**
   * The ID of the source record whose properties need to be cloned into the target record
   *
   * @generated from field: uint64 source_id = 1;
   */
  sourceId = protoInt64.zero;

  /**
   * The ID of the target record that will store the cloned properties from the source
   *
   * @generated from field: uint64 target_id = 2;
   */
  targetId = protoInt64.zero;

  /**
   * Stores if the existing items in the target resource need to be deleted before cloning from the source resource
   *
   * @generated from field: bool delete_existing = 3;
   */
  deleteExisting = false;

  /**
   * The comment entered by the user
   *
   * @generated from field: string user_comment = 4;
   */
  userComment = "";

  constructor(data?: PartialMessage<CloneRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.CloneRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "target_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "delete_existing", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "user_comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CloneRequest {
    return new CloneRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CloneRequest {
    return new CloneRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CloneRequest {
    return new CloneRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CloneRequest | PlainMessage<CloneRequest> | undefined, b: CloneRequest | PlainMessage<CloneRequest> | undefined): boolean {
    return proto3.util.equals(CloneRequest, a, b);
  }
}

/**
 *
 * Describes the payload that consists of a file
 *
 * @generated from message Scailo.StandardFile
 */
export class StandardFile extends Message<StandardFile> {
  /**
   * Stores the name of the file
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Stores the MIME type of the file
   *
   * @generated from field: string mime_type = 2;
   */
  mimeType = "";

  /**
   * Stores the raw file content
   *
   * @generated from field: bytes content = 10;
   */
  content = new Uint8Array(0);

  constructor(data?: PartialMessage<StandardFile>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.StandardFile";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "mime_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "content", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StandardFile {
    return new StandardFile().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StandardFile {
    return new StandardFile().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StandardFile {
    return new StandardFile().fromJsonString(jsonString, options);
  }

  static equals(a: StandardFile | PlainMessage<StandardFile> | undefined, b: StandardFile | PlainMessage<StandardFile> | undefined): boolean {
    return proto3.util.equals(StandardFile, a, b);
  }
}

/**
 *
 * Describes each parameter that's part of the logbook (does not include historical data of the object) with the operation being a inventory lifecycle status
 *
 * @generated from message Scailo.LogbookLogInventoryLC
 */
export class LogbookLogInventoryLC extends Message<LogbookLogInventoryLC> {
  /**
   * ID of the resource
   *
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * Stores if the resource is active
   *
   * @generated from field: bool is_active = 2;
   */
  isActive = false;

  /**
   * Stores the timestamp of when this resource was created
   *
   * @generated from field: uint64 timestamp = 3;
   */
  timestamp = protoInt64.zero;

  /**
   * The UUID of the resource
   *
   * @generated from field: string ref_uuid = 10;
   */
  refUuid = "";

  /**
   * The operation that was performed
   *
   * @generated from field: Scailo.INVENTORY_LIFECYCLE operation = 11;
   */
  operation = INVENTORY_LIFECYCLE.INVENTORY_LIFECYCLE_ANY_UNSPECIFIED;

  /**
   * The username of the user who performed this operation
   *
   * @generated from field: string username = 12;
   */
  username = "";

  /**
   * The name of the person who made this entry
   *
   * @generated from field: string name = 13;
   */
  name = "";

  /**
   * The ID of the user who made this entry
   *
   * @generated from field: uint64 user_id = 14;
   */
  userId = protoInt64.zero;

  /**
   * The comment generated by the application
   *
   * @generated from field: string app_comment = 15;
   */
  appComment = "";

  /**
   * The comment entered by the user
   *
   * @generated from field: string user_comment = 16;
   */
  userComment = "";

  constructor(data?: PartialMessage<LogbookLogInventoryLC>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.LogbookLogInventoryLC";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "is_active", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "timestamp", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 10, name: "ref_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "operation", kind: "enum", T: proto3.getEnumType(INVENTORY_LIFECYCLE) },
    { no: 12, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "user_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 15, name: "app_comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "user_comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogbookLogInventoryLC {
    return new LogbookLogInventoryLC().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogbookLogInventoryLC {
    return new LogbookLogInventoryLC().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogbookLogInventoryLC {
    return new LogbookLogInventoryLC().fromJsonString(jsonString, options);
  }

  static equals(a: LogbookLogInventoryLC | PlainMessage<LogbookLogInventoryLC> | undefined, b: LogbookLogInventoryLC | PlainMessage<LogbookLogInventoryLC> | undefined): boolean {
    return proto3.util.equals(LogbookLogInventoryLC, a, b);
  }
}

/**
 *
 * Describes the parameters required to partition an inventory lot
 *
 * @generated from message Scailo.InventoryPartitionRequest
 */
export class InventoryPartitionRequest extends Message<InventoryPartitionRequest> {
  /**
   * ID of the resource
   *
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * Stores any comment that the user might add during this operation
   *
   * @generated from field: string user_comment = 2;
   */
  userComment = "";

  /**
   * The primary quantity of the new partition
   *
   * @generated from field: uint64 partition_quantity = 10;
   */
  partitionQuantity = protoInt64.zero;

  /**
   * The secondary quantity of the new partition
   *
   * @generated from field: uint64 partition_secondary_quantity = 11;
   */
  partitionSecondaryQuantity = protoInt64.zero;

  constructor(data?: PartialMessage<InventoryPartitionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.InventoryPartitionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "user_comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "partition_quantity", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 11, name: "partition_secondary_quantity", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InventoryPartitionRequest {
    return new InventoryPartitionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InventoryPartitionRequest {
    return new InventoryPartitionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InventoryPartitionRequest {
    return new InventoryPartitionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: InventoryPartitionRequest | PlainMessage<InventoryPartitionRequest> | undefined, b: InventoryPartitionRequest | PlainMessage<InventoryPartitionRequest> | undefined): boolean {
    return proto3.util.equals(InventoryPartitionRequest, a, b);
  }
}

/**
 *
 * Stores the parameters present within an inventory interaction
 *
 * @generated from message Scailo.InventoryInteraction
 */
export class InventoryInteraction extends Message<InventoryInteraction> {
  /**
   * Stores a globally unique entity UUID. This will be set at the organization level
   *
   * @generated from field: string entity_uuid = 1;
   */
  entityUuid = "";

  /**
   * Stores the metadata of this interaction
   *
   * @generated from field: Scailo.EmployeeMetadata metadata = 2;
   */
  metadata?: EmployeeMetadata;

  /**
   * Stores the category
   *
   * @generated from field: Scailo.INVENTORY_INTERACTION_CATEGORY category = 10;
   */
  category = INVENTORY_INTERACTION_CATEGORY.INVENTORY_INTERACTION_CATEGORY_ANY_UNSPECIFIED;

  /**
   * Stores the UUID of the inventory item
   *
   * @generated from field: string inventory_ref_uuid = 11;
   */
  inventoryRefUuid = "";

  /**
   * Stores the hash of the inventory item that has been issued from this parent item
   *
   * @generated from field: string issued_inventory_hash = 12;
   */
  issuedInventoryHash = "";

  /**
   * Stores the purpose for which this new item has been issued, for e.g. 'stock-issuance'
   *
   * @generated from field: Scailo.INVENTORY_ISSUED_PURPOSE issued_ref_purpose = 13;
   */
  issuedRefPurpose = INVENTORY_ISSUED_PURPOSE.INVENTORY_ISSUED_PURPOSE_ANY_UNSPECIFIED;

  /**
   * Stores the ID of the corresponding issued_ref_purpose item, for e.g., the stock-issuance ID
   *
   * @generated from field: uint64 issued_ref_id = 14;
   */
  issuedRefId = protoInt64.zero;

  /**
   * Stores the quantity of this item (in cents). Can be negative since this could also be an adjustment
   *
   * @generated from field: int64 internal_quantity = 15;
   */
  internalQuantity = protoInt64.zero;

  constructor(data?: PartialMessage<InventoryInteraction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.InventoryInteraction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metadata", kind: "message", T: EmployeeMetadata },
    { no: 10, name: "category", kind: "enum", T: proto3.getEnumType(INVENTORY_INTERACTION_CATEGORY) },
    { no: 11, name: "inventory_ref_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "issued_inventory_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "issued_ref_purpose", kind: "enum", T: proto3.getEnumType(INVENTORY_ISSUED_PURPOSE) },
    { no: 14, name: "issued_ref_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 15, name: "internal_quantity", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InventoryInteraction {
    return new InventoryInteraction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InventoryInteraction {
    return new InventoryInteraction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InventoryInteraction {
    return new InventoryInteraction().fromJsonString(jsonString, options);
  }

  static equals(a: InventoryInteraction | PlainMessage<InventoryInteraction> | undefined, b: InventoryInteraction | PlainMessage<InventoryInteraction> | undefined): boolean {
    return proto3.util.equals(InventoryInteraction, a, b);
  }
}

/**
 *
 * Describes the list of inventory interactions
 *
 * @generated from message Scailo.InventoryInteractionsList
 */
export class InventoryInteractionsList extends Message<InventoryInteractionsList> {
  /**
   * List of interactions
   *
   * @generated from field: repeated Scailo.InventoryInteraction list = 1;
   */
  list: InventoryInteraction[] = [];

  constructor(data?: PartialMessage<InventoryInteractionsList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.InventoryInteractionsList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "list", kind: "message", T: InventoryInteraction, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InventoryInteractionsList {
    return new InventoryInteractionsList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InventoryInteractionsList {
    return new InventoryInteractionsList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InventoryInteractionsList {
    return new InventoryInteractionsList().fromJsonString(jsonString, options);
  }

  static equals(a: InventoryInteractionsList | PlainMessage<InventoryInteractionsList> | undefined, b: InventoryInteractionsList | PlainMessage<InventoryInteractionsList> | undefined): boolean {
    return proto3.util.equals(InventoryInteractionsList, a, b);
  }
}

/**
 *
 * Describes the data payload within an amendment log
 *
 * @generated from message Scailo.AmendmentLog
 */
export class AmendmentLog extends Message<AmendmentLog> {
  /**
   * Stores a globally unique entity UUID. This will be set at the organization level
   *
   * @generated from field: string entity_uuid = 1;
   */
  entityUuid = "";

  /**
   * Stores the metada of this resource
   *
   * @generated from field: Scailo.EmployeeMetadata metadata = 2;
   */
  metadata?: EmployeeMetadata;

  /**
   * Stores the reference
   *
   * @generated from field: Scailo.AMENDMENT_LOG_REF_FOR ref_for = 10;
   */
  refFor = AMENDMENT_LOG_REF_FOR.AMENDMENT_LOG_REF_FOR_ANY_UNSPECIFIED;

  /**
   * Stores the ID of the reference
   *
   * @generated from field: uint64 ref_id = 11;
   */
  refId = protoInt64.zero;

  /**
   * Stores the comment
   *
   * @generated from field: string comment = 20;
   */
  comment = "";

  constructor(data?: PartialMessage<AmendmentLog>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.AmendmentLog";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metadata", kind: "message", T: EmployeeMetadata },
    { no: 10, name: "ref_for", kind: "enum", T: proto3.getEnumType(AMENDMENT_LOG_REF_FOR) },
    { no: 11, name: "ref_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 20, name: "comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AmendmentLog {
    return new AmendmentLog().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AmendmentLog {
    return new AmendmentLog().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AmendmentLog {
    return new AmendmentLog().fromJsonString(jsonString, options);
  }

  static equals(a: AmendmentLog | PlainMessage<AmendmentLog> | undefined, b: AmendmentLog | PlainMessage<AmendmentLog> | undefined): boolean {
    return proto3.util.equals(AmendmentLog, a, b);
  }
}

/**
 *
 * Describes the list of amendment logs
 *
 * @generated from message Scailo.AmendmentLogsList
 */
export class AmendmentLogsList extends Message<AmendmentLogsList> {
  /**
   * List of amendment logs
   *
   * @generated from field: repeated Scailo.AmendmentLog list = 1;
   */
  list: AmendmentLog[] = [];

  constructor(data?: PartialMessage<AmendmentLogsList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.AmendmentLogsList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "list", kind: "message", T: AmendmentLog, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AmendmentLogsList {
    return new AmendmentLogsList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AmendmentLogsList {
    return new AmendmentLogsList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AmendmentLogsList {
    return new AmendmentLogsList().fromJsonString(jsonString, options);
  }

  static equals(a: AmendmentLogsList | PlainMessage<AmendmentLogsList> | undefined, b: AmendmentLogsList | PlainMessage<AmendmentLogsList> | undefined): boolean {
    return proto3.util.equals(AmendmentLogsList, a, b);
  }
}

