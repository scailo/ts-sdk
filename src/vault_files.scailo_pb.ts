// @generated by protoc-gen-es v1.5.1 with parameter "target=ts"
// @generated from file vault_files.scailo.proto (package Scailo, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { EmployeeMetadata } from "./base.scailo_pb.js";
import { VaultPermission } from "./vault_commons.scailo_pb.js";

/**
 *
 * Describes the parameters necessary to initiate a vault file
 *
 * @generated from message Scailo.VaultFileInitiateFileRequest
 */
export class VaultFileInitiateFileRequest extends Message<VaultFileInitiateFileRequest> {
  /**
   * Stores a globally unique entity UUID. This will be set at the organization level
   *
   * @generated from field: string entity_uuid = 1;
   */
  entityUuid = "";

  /**
   * Stores any comment that the user might add during this operation
   *
   * @generated from field: string user_comment = 2;
   */
  userComment = "";

  /**
   * The name of the file
   *
   * @generated from field: string name = 10;
   */
  name = "";

  /**
   * The file type
   *
   * @generated from field: string type = 11;
   */
  type = "";

  /**
   * The UUID of the folder that the file is present in
   *
   * @generated from field: string folder_uuid = 13;
   */
  folderUuid = "";

  constructor(data?: PartialMessage<VaultFileInitiateFileRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.VaultFileInitiateFileRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "user_comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "folder_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VaultFileInitiateFileRequest {
    return new VaultFileInitiateFileRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VaultFileInitiateFileRequest {
    return new VaultFileInitiateFileRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VaultFileInitiateFileRequest {
    return new VaultFileInitiateFileRequest().fromJsonString(jsonString, options);
  }

  static equals(a: VaultFileInitiateFileRequest | PlainMessage<VaultFileInitiateFileRequest> | undefined, b: VaultFileInitiateFileRequest | PlainMessage<VaultFileInitiateFileRequest> | undefined): boolean {
    return proto3.util.equals(VaultFileInitiateFileRequest, a, b);
  }
}

/**
 *
 * Describes the payload in the response to a file initiate request
 *
 * @generated from message Scailo.VaultFileInitiateFileResponse
 */
export class VaultFileInitiateFileResponse extends Message<VaultFileInitiateFileResponse> {
  /**
   * The UUID of the file
   *
   * @generated from field: string uuid = 1;
   */
  uuid = "";

  /**
   * The max size of the chunk (in bytes) for uploading a file
   *
   * @generated from field: uint64 chunk_size = 2;
   */
  chunkSize = protoInt64.zero;

  constructor(data?: PartialMessage<VaultFileInitiateFileResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.VaultFileInitiateFileResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "chunk_size", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VaultFileInitiateFileResponse {
    return new VaultFileInitiateFileResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VaultFileInitiateFileResponse {
    return new VaultFileInitiateFileResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VaultFileInitiateFileResponse {
    return new VaultFileInitiateFileResponse().fromJsonString(jsonString, options);
  }

  static equals(a: VaultFileInitiateFileResponse | PlainMessage<VaultFileInitiateFileResponse> | undefined, b: VaultFileInitiateFileResponse | PlainMessage<VaultFileInitiateFileResponse> | undefined): boolean {
    return proto3.util.equals(VaultFileInitiateFileResponse, a, b);
  }
}

/**
 *
 * Describes the parameters necessary to rename a vault file
 *
 * @generated from message Scailo.VaultFileRenameFileRequest
 */
export class VaultFileRenameFileRequest extends Message<VaultFileRenameFileRequest> {
  /**
   * The UUID of the file
   *
   * @generated from field: string uuid = 1;
   */
  uuid = "";

  /**
   * The new name of the file
   *
   * @generated from field: string name = 10;
   */
  name = "";

  constructor(data?: PartialMessage<VaultFileRenameFileRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.VaultFileRenameFileRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VaultFileRenameFileRequest {
    return new VaultFileRenameFileRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VaultFileRenameFileRequest {
    return new VaultFileRenameFileRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VaultFileRenameFileRequest {
    return new VaultFileRenameFileRequest().fromJsonString(jsonString, options);
  }

  static equals(a: VaultFileRenameFileRequest | PlainMessage<VaultFileRenameFileRequest> | undefined, b: VaultFileRenameFileRequest | PlainMessage<VaultFileRenameFileRequest> | undefined): boolean {
    return proto3.util.equals(VaultFileRenameFileRequest, a, b);
  }
}

/**
 *
 * Describes the parameters necessary to move a vault file
 *
 * @generated from message Scailo.VaultFileMoveFileRequest
 */
export class VaultFileMoveFileRequest extends Message<VaultFileMoveFileRequest> {
  /**
   * The UUID of the file
   *
   * @generated from field: string uuid = 1;
   */
  uuid = "";

  /**
   * The UUID of the destination folder that the file needs to be moved into
   *
   * @generated from field: string destination_folder_uuid = 13;
   */
  destinationFolderUuid = "";

  constructor(data?: PartialMessage<VaultFileMoveFileRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.VaultFileMoveFileRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "destination_folder_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VaultFileMoveFileRequest {
    return new VaultFileMoveFileRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VaultFileMoveFileRequest {
    return new VaultFileMoveFileRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VaultFileMoveFileRequest {
    return new VaultFileMoveFileRequest().fromJsonString(jsonString, options);
  }

  static equals(a: VaultFileMoveFileRequest | PlainMessage<VaultFileMoveFileRequest> | undefined, b: VaultFileMoveFileRequest | PlainMessage<VaultFileMoveFileRequest> | undefined): boolean {
    return proto3.util.equals(VaultFileMoveFileRequest, a, b);
  }
}

/**
 *
 * Describes the parameters of a vault file
 *
 * @generated from message Scailo.VaultFile
 */
export class VaultFile extends Message<VaultFile> {
  /**
   * Stores a globally unique entity UUID. This will be set at the organization level
   *
   * @generated from field: string entity_uuid = 1;
   */
  entityUuid = "";

  /**
   * Stores the metadata of this user
   *
   * @generated from field: Scailo.EmployeeMetadata metadata = 2;
   */
  metadata?: EmployeeMetadata;

  /**
   * The timestamp of when the file upload was completed
   *
   * @generated from field: uint64 completed_at = 6;
   */
  completedAt = protoInt64.zero;

  /**
   * The name of the file
   *
   * @generated from field: string name = 10;
   */
  name = "";

  /**
   * The file type
   *
   * @generated from field: string type = 11;
   */
  type = "";

  /**
   * Stores if the file has been made persistent
   *
   * @generated from field: bool is_persistent = 12;
   */
  isPersistent = false;

  /**
   * The ID of the folder that the file lives in
   *
   * @generated from field: uint64 folder_id = 13;
   */
  folderId = protoInt64.zero;

  /**
   * The path of the file
   *
   * @generated from field: string path_tree = 14;
   */
  pathTree = "";

  /**
   * The size of the file in bytes
   *
   * @generated from field: uint64 size = 20;
   */
  size = protoInt64.zero;

  /**
   * The list of permissions
   *
   * @generated from field: repeated Scailo.VaultPermission permissions = 30;
   */
  permissions: VaultPermission[] = [];

  /**
   * The UUID of the folder that the file is present in
   *
   * @generated from field: string folder_uuid = 50;
   */
  folderUuid = "";

  constructor(data?: PartialMessage<VaultFile>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.VaultFile";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metadata", kind: "message", T: EmployeeMetadata },
    { no: 6, name: "completed_at", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 10, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "is_persistent", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "folder_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 14, name: "path_tree", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "size", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 30, name: "permissions", kind: "message", T: VaultPermission, repeated: true },
    { no: 50, name: "folder_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VaultFile {
    return new VaultFile().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VaultFile {
    return new VaultFile().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VaultFile {
    return new VaultFile().fromJsonString(jsonString, options);
  }

  static equals(a: VaultFile | PlainMessage<VaultFile> | undefined, b: VaultFile | PlainMessage<VaultFile> | undefined): boolean {
    return proto3.util.equals(VaultFile, a, b);
  }
}

/**
 *
 * Describes the message consisting of the list of vault files
 *
 * @generated from message Scailo.VaultFilesList
 */
export class VaultFilesList extends Message<VaultFilesList> {
  /**
   * List of files
   *
   * @generated from field: repeated Scailo.VaultFile list = 1;
   */
  list: VaultFile[] = [];

  constructor(data?: PartialMessage<VaultFilesList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.VaultFilesList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "list", kind: "message", T: VaultFile, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VaultFilesList {
    return new VaultFilesList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VaultFilesList {
    return new VaultFilesList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VaultFilesList {
    return new VaultFilesList().fromJsonString(jsonString, options);
  }

  static equals(a: VaultFilesList | PlainMessage<VaultFilesList> | undefined, b: VaultFilesList | PlainMessage<VaultFilesList> | undefined): boolean {
    return proto3.util.equals(VaultFilesList, a, b);
  }
}

/**
 *
 * Describes the parameres of a version of each file
 *
 * @generated from message Scailo.VaultFileVersion
 */
export class VaultFileVersion extends Message<VaultFileVersion> {
  /**
   * Stores a globally unique entity UUID. This will be set at the organization level
   *
   * @generated from field: string entity_uuid = 1;
   */
  entityUuid = "";

  /**
   * Stores the metadata of this user
   *
   * @generated from field: Scailo.EmployeeMetadata metadata = 2;
   */
  metadata?: EmployeeMetadata;

  /**
   * The timestamp of when the file version upload was completed
   *
   * @generated from field: uint64 completed_at = 6;
   */
  completedAt = protoInt64.zero;

  /**
   * Stores the ID of the file that the version belongs to
   *
   * @generated from field: uint64 vault_file_id = 10;
   */
  vaultFileId = protoInt64.zero;

  /**
   * The name of the file
   *
   * @generated from field: string name = 11;
   */
  name = "";

  /**
   * The file type
   *
   * @generated from field: string type = 12;
   */
  type = "";

  /**
   * The size of the file version in bytes
   *
   * @generated from field: uint64 size = 20;
   */
  size = protoInt64.zero;

  constructor(data?: PartialMessage<VaultFileVersion>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.VaultFileVersion";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metadata", kind: "message", T: EmployeeMetadata },
    { no: 6, name: "completed_at", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 10, name: "vault_file_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 11, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "size", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VaultFileVersion {
    return new VaultFileVersion().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VaultFileVersion {
    return new VaultFileVersion().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VaultFileVersion {
    return new VaultFileVersion().fromJsonString(jsonString, options);
  }

  static equals(a: VaultFileVersion | PlainMessage<VaultFileVersion> | undefined, b: VaultFileVersion | PlainMessage<VaultFileVersion> | undefined): boolean {
    return proto3.util.equals(VaultFileVersion, a, b);
  }
}

/**
 *
 * Describes the message consisting of the list of vault file versions
 *
 * @generated from message Scailo.VaultFileVersionsList
 */
export class VaultFileVersionsList extends Message<VaultFileVersionsList> {
  /**
   * List of versions of the file
   *
   * @generated from field: repeated Scailo.VaultFileVersion list = 1;
   */
  list: VaultFileVersion[] = [];

  constructor(data?: PartialMessage<VaultFileVersionsList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.VaultFileVersionsList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "list", kind: "message", T: VaultFileVersion, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VaultFileVersionsList {
    return new VaultFileVersionsList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VaultFileVersionsList {
    return new VaultFileVersionsList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VaultFileVersionsList {
    return new VaultFileVersionsList().fromJsonString(jsonString, options);
  }

  static equals(a: VaultFileVersionsList | PlainMessage<VaultFileVersionsList> | undefined, b: VaultFileVersionsList | PlainMessage<VaultFileVersionsList> | undefined): boolean {
    return proto3.util.equals(VaultFileVersionsList, a, b);
  }
}

/**
 *
 * Describes the parameters necessary to add a chunk to a file
 *
 * @generated from message Scailo.VaultFileAddChunkRequest
 */
export class VaultFileAddChunkRequest extends Message<VaultFileAddChunkRequest> {
  /**
   * The UUID of the file
   *
   * @generated from field: string uuid = 1;
   */
  uuid = "";

  /**
   * Stores the sequence ID of this chunk
   *
   * @generated from field: uint64 sequence_id = 11;
   */
  sequenceId = protoInt64.zero;

  /**
   * Stores the content of the chunk
   *
   * @generated from field: bytes chunk = 12;
   */
  chunk = new Uint8Array(0);

  constructor(data?: PartialMessage<VaultFileAddChunkRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.VaultFileAddChunkRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "sequence_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 12, name: "chunk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VaultFileAddChunkRequest {
    return new VaultFileAddChunkRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VaultFileAddChunkRequest {
    return new VaultFileAddChunkRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VaultFileAddChunkRequest {
    return new VaultFileAddChunkRequest().fromJsonString(jsonString, options);
  }

  static equals(a: VaultFileAddChunkRequest | PlainMessage<VaultFileAddChunkRequest> | undefined, b: VaultFileAddChunkRequest | PlainMessage<VaultFileAddChunkRequest> | undefined): boolean {
    return proto3.util.equals(VaultFileAddChunkRequest, a, b);
  }
}

/**
 *
 * Describes the parameters of each chunk of a file version
 *
 * @generated from message Scailo.VaultFileVersionChunk
 */
export class VaultFileVersionChunk extends Message<VaultFileVersionChunk> {
  /**
   * Stores a globally unique entity UUID. This will be set at the organization level
   *
   * @generated from field: string entity_uuid = 1;
   */
  entityUuid = "";

  /**
   * Stores the metadata of this user
   *
   * @generated from field: Scailo.EmployeeMetadata metadata = 2;
   */
  metadata?: EmployeeMetadata;

  /**
   * Stores the ID of the file version to which this chunk belongs
   *
   * @generated from field: uint64 vault_file_version_id = 10;
   */
  vaultFileVersionId = protoInt64.zero;

  /**
   * Stores the sequence ID of this chunk
   *
   * @generated from field: uint64 sequence_id = 11;
   */
  sequenceId = protoInt64.zero;

  /**
   * Stores the content of the chunk
   *
   * @generated from field: bytes chunk = 12;
   */
  chunk = new Uint8Array(0);

  /**
   * Stores the checksum of the chunk
   *
   * @generated from field: string checksum = 13;
   */
  checksum = "";

  constructor(data?: PartialMessage<VaultFileVersionChunk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.VaultFileVersionChunk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metadata", kind: "message", T: EmployeeMetadata },
    { no: 10, name: "vault_file_version_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 11, name: "sequence_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 12, name: "chunk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 13, name: "checksum", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VaultFileVersionChunk {
    return new VaultFileVersionChunk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VaultFileVersionChunk {
    return new VaultFileVersionChunk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VaultFileVersionChunk {
    return new VaultFileVersionChunk().fromJsonString(jsonString, options);
  }

  static equals(a: VaultFileVersionChunk | PlainMessage<VaultFileVersionChunk> | undefined, b: VaultFileVersionChunk | PlainMessage<VaultFileVersionChunk> | undefined): boolean {
    return proto3.util.equals(VaultFileVersionChunk, a, b);
  }
}

/**
 *
 * Stores the request to unzip a zipped file
 *
 * @generated from message Scailo.VaultFileUnzipRequest
 */
export class VaultFileUnzipRequest extends Message<VaultFileUnzipRequest> {
  /**
   * The UUID of the file that needs to be unzipped
   *
   * @generated from field: string uuid = 1;
   */
  uuid = "";

  /**
   * Stores if the file needs to be deleted after unzipping
   *
   * @generated from field: bool delete_after_unzip = 2;
   */
  deleteAfterUnzip = false;

  constructor(data?: PartialMessage<VaultFileUnzipRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Scailo.VaultFileUnzipRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "delete_after_unzip", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VaultFileUnzipRequest {
    return new VaultFileUnzipRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VaultFileUnzipRequest {
    return new VaultFileUnzipRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VaultFileUnzipRequest {
    return new VaultFileUnzipRequest().fromJsonString(jsonString, options);
  }

  static equals(a: VaultFileUnzipRequest | PlainMessage<VaultFileUnzipRequest> | undefined, b: VaultFileUnzipRequest | PlainMessage<VaultFileUnzipRequest> | undefined): boolean {
    return proto3.util.equals(VaultFileUnzipRequest, a, b);
  }
}

